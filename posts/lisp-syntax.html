<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>Subset Park: lisp syntax</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content="{loglevel, debug}"><meta name=author content="Z. D. Smith"><link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=../assets/bootstrap.min.css rel=stylesheet><link href=../assets/bootstrap-responsive.min.css rel=stylesheet><link href=../assets/styles.css rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/styles/ascetic.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=alternate type=application/rss+xml title=RSS href=../feed.xml></head> <body> <div class=container> <div class=row> <div class=col-md-1></div> <div class=col-md-10> <div class=masthead> <div class=navbar> <div class=navbar-inner> <div class=container> <ul class=nav> <li class=active><a href=../index.html>Home</a></li> <li><a href=../posts/index.html>Posts</a></li> <li><a href=../notes/index.html>Notes</a></li> <li><a href=../pages/about.html>About</a></li> <li><a href=../pages/illustrated-whist.html>Illustrated Whist</a></li> </ul> </div> </div> </div><!-- /.navbar --> </div> <div class=body> <div class=container> <div class=row> <div class=col-md-7> <h1>lisp syntax</h1> <p class=post-info> 2021-09-01 </p> <p>Who cares about Lisp, exactly? Many different groups, apparently. Lisp---the family of languages in some way diachronically related to the language, LISP, or synchronically built around s-expressions[^sexps]---continues to inspire thumbsuckers, as my old music journalism professor taught me to call them. When you wrote a column, you had to allow yourself only a certain abstemious ratio of thumbsuckers to actual, bread and butter news and reviews. Of course, I was only interested in the conceptual stuff. I had absolutely no journalistic gumption. Hence, I am a Lisp programmer.</p> <p>[^sexps]: The first heresy!</p> <p>One of the problems is quite simply that Lisp is a complex thing with many interesting bits to it. We've already touched on the fact that it is <em>at least</em> two things. These two things are already more than enough source of confusion: at this point you don't know if I'm going to wax poetic about John McCarthy's singular primeval genius, or if I'm going to try to convince you that all modern business programming is properly done in Clojure.</p> <p>Let's be more specific. Here are some of the reasons why a reasonable person on the internet might be convinced that Lisp is Important and Worth Understanding:</p> <ul> <li>The singularity and genius of the <a href=http://jmc.stanford.edu/articles/lisp.html>artifact</a> that was invented by McCarthy in 1958;</li> <li>The realization of the <a href=http://www.cs.cornell.edu/courses/cs312/2008sp/recitations/rec26.html>Lambda Calculus</a> in computer program form;</li> <li>The conceptual integrity of the <a href=https://mitpress.mit.edu/sites/default/files/sicp/full-text/sicp/book/node76.html>Metacircular Evaluator</a> and the attendent minimalism of the language it requires/implements;</li> <li>The unreasonable effectiveness of <a href=https://letoverlambda.com/ >macros</a>;</li> <li><a href=https://wiki.c2.com/?LispMachine>Lisp Machines</a>;</li> <li>The <a href=https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>various</a> <a href=https://lispcast.com/what-are-first-class-functions/ >future</a> <a href=https://mikelevins.github.io/posts/2020-12-18-repl-driven/ >technologies</a> <a href=https://www.adamtornhill.com/reviews/amop.htm>rattling</a> <a href=https://www.reddit.com/r/lisp/comments/go3dzr/what_is_image_based_programming/ >around</a> the Steel Bank Common Lisp implementation, which are still being rediscovered by other, newer languages, and of which some will remain forever undiscovered except by those Lispers who have been using them daily since 1980;</li> <li>The practice of <a href=https://beautifulracket.com/appendix/domain-specific-languages.html>writing languages</a> to solve problems rather than simply writing programs;</li> <li>et al.</li> </ul> <p>The point is that none of these things are <em>essentially related</em>. They're related by virtue of being found in the same language, or family of language, yes; and many of them share in common the features of that language which make them possible. But no two of them rely on exactly the same set of features. Let alone the same essential, mystical Lispiness.</p> <p>So let me pick a particular slice to talk about. I want to stress that I am not articulating the <em>soul of Lisp</em>; I'm carving out a particular bit, which bit will surely be related to other bits, make them more possible, make them more ergonomic, et cetera.</p> <h1>The Veil of Syntax</h1> <blockquote> <p>The reliable facts are not that which is subjective, not that which is objective, not a mixture of the two, but never unreasonable at all.</p> <p>Phenomena are just recognized as they are, and existence as we conceive it never exists anywhere; it is just nonexistence.</p> </blockquote> <ul> <li>Nagarjuna, <em>Fundamental Wisdom of the Middle Way</em>, tr. Gudo Wafu Nishijima</li> </ul> <p>I have to continually resist the urge to essentialism. I nearly began this section, &quot;the central insight of Lisp is...&quot;</p> <p>Instead: one of the insights that will rattle around your head after you've been using Lisp for a while, and change the way you experience other programming language is: <strong>syntax</strong> is a largely unuseful fiction in programming.</p> <h2>ASTs</h2> <p>Those of us who have ever tried to reach a little ways into the guts of the programming languages we use have probably encountered an <em>Abstract Syntax Tree</em>.</p> <p>The Abstract Syntax Tree, or AST, is a data structure describing a tree-like structure which relates the different words in the source code of a program to each other. Let us observe some:</p> <p><em>A Python program</em></p> <pre><code class=language-python>def id(x):
  return x

</code></pre> <pre><code class=language-python>&gt;&gt;&gt; import ast
&gt;&gt;&gt; print(ast.dump(ast.parse(&quot;def id(x):\n  return x\n&quot;)))
Module(body=[FunctionDef(name='id', 
                         args=arguments(posonlyargs=[], 
                                        args=[arg(arg='x')], 
                                        kwonlyargs=[], 
                                        kw_defaults=[], 
                                        defaults=[]), 
                         body=[Return(value=Name(id='x', ctx=Load()))], 
                         decorator_list=[])], 
       type_ignores=[])
&gt;&gt;&gt;
</code></pre> <p><em>An Elixir program</em></p> <pre><code class=language-elixir>def id(x) do
  x
end
</code></pre> <pre><code class=language-elixir>iex(1)&gt; quote do
...(1)&gt;   def id(x) do
...(1)&gt;     x
...(1)&gt;   end
...(1)&gt; end
{:def, [context: Elixir, import: Kernel],
 [{:id, [context: Elixir], [{:x, [], Elixir}]}, [do: {:x, [], Elixir}]]}
iex(2)&gt;
</code></pre> <p>Above, there are four things:</p> <ul> <li>Two examples of <em>program syntax</em>, one for a Python program that defines the identity function and one for an Elixir program that does the same;</li> <li>Two examples of <em>ASTs</em>, the representation of those programs using the data structures of the language to store terms representing the tokens (I'm going to keep saying &quot;words&quot; for simplicity) in a relationship to each other that mirrors the way the words relate to each other syntactically.</li> </ul> <p>The syntaxes of the two languages are a little different. The ASTs are quite different; Python uses objects, instances of specialized classes, and Elixir uses tuples, lists, and keywords.</p> <p>The important thing that both ASTs convey is the <em>structure</em> of the words, how they relate to each other. And they relate to each other as a tree. There is a root node, representing the whole program, and it has 0 or more children, which are other nodes, representing parts of the program. Those children have their own children until we hit the bottom. In both cases, for instance, a <code>def</code> form is a node which has more-or-less three children:</p> <ol> <li>a name;</li> <li>arguments;</li> <li>a function body.</li> </ol> <p>The children, in order to be useful, will probably be complex nodes themselves, with their own children---especially the function body.</p> <p>Thus is the nature of all source code, quite nearly[^allsource]. It's all trees. A parser takes source code, produces an abstract syntax tree, which is then interpreted, evaluated, or analyzed.</p> <p>[^allsource]: Except maybe Forth.</p> <h3>Taking the Syntax Out</h3> <p>The motto of the LFE (Lisp Flavoured Erlang) programming language is, <a href=https://lfe.io/ >&quot;Taking the syntax out of distributed systems programming&quot;</a>. This seems like something of an odd boast. Generally, syntax of some kind would seem to be a virtue. Otherwise, you're just programming directly with those trees.</p> <p>Well, yes, quite. Let's repeat the above AST exercise in a Lisp. I'll pick <a href=janet-lang.org/ >Janet</a>.</p> <p><em>A Janet program</em></p> <pre><code class=language-clj>(defn id
 [x]
 x)
</code></pre> <pre><code class=language-clj>repl:1:&gt; (quote (defn id [x] x))
(defn id [x] x)
</code></pre> <p>In this case, the program is the familiar moonscape of parentheses, denuded of colons and curly braces and do/ends. And the AST of that program is trivial: it's the exact same thing.</p> <p>In Janet, a tuple is a sequence of tokens bounded by parentheses or square braces, and a symbol is a bare word without any quotes around it. So the AST for my program is simply a tuple with four elements: a symbol, a symbol, a tuple, and a symbol. That inner tuple has a single element: a symbol.</p> <p>The really important thing here is that lists (or tuples), too, can be trees. Let us decide to treat the first element of a list as the &quot;type&quot; of a node, and all the subsequent elements as the children of that node.</p> <p>We have just invented s-expressions, the core syntactic construct at the heart of every Lisp (I <em>do</em> feel quite comfortable being essentialist here).</p> <p>The only use of s-expressions is that they give us something that's quite easy to write and quite easy to parse that <em>directly expresses a tree structure.</em></p> <p>In other words, they allow us to skip the syntax step. And it is one of Lisp's core contentions that, while a pleasant syntax is superficially appealing, you won't miss it.</p> </div> <div class=col-md-3> <h3>Recent Posts</h3> <table class=recent-posts> <tr> <td style=white-space:nowrap>2022-02-19</td> <td><a href=../posts/a-specification-of-a-note-taking-program.html>A Specification of a Note-Taking Program</a></td> </tr> <tr> <td style=white-space:nowrap>2021-03-20</td> <td><a href=../posts/algorithms-im-proud-of-fill.html>Algorithms I'm Proud Of: Fill</a></td> </tr> <tr> <td style=white-space:nowrap>2020-12-10</td> <td><a href=../posts/bagatto-a-new-static-site-generator.html>Bagatto, a New Static Site Generator</a></td> </tr> <tr> <td style=white-space:nowrap>2020-11-22</td> <td><a href=../posts/a-regular-simplification-of-offenbacher-schrift.html>A Regular Simplification of Offenbacher Schrift</a></td> </tr> <tr> <td style=white-space:nowrap>2020-08-20</td> <td><a href=../posts/mariglia.html>Mariglia</a></td> </tr> </table> </div> </div> </div> </div> <hr> <div class=footer>Built with <a href=https://bagatto.co>Bagatto.</a></div> </div> </div> </div> </body> </html> 