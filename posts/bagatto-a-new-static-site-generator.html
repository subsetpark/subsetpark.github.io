<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>Subset Park: Bagatto, a New Static Site Generator</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content="{loglevel, debug}"><meta name=author content="Z. D. Smith"><link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=../assets/bootstrap.min.css rel=stylesheet><link href=../assets/bootstrap-responsive.min.css rel=stylesheet><link href=../assets/styles.css rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/styles/ascetic.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=alternate type=application/rss+xml title=RSS href=../feed.xml></head> <body> <div class=container> <div class=row> <div class=col-md-1></div> <div class=col-md-10> <div class=masthead> <div class=navbar> <div class=navbar-inner> <div class=container> <ul class=nav> <li class=active><a href=../index.html>Home</a></li> <li><a href=../posts/index.html>Posts</a></li> <li><a href=../notes/index.html>Notes</a></li> <li><a href=../pages/about.html>About</a></li> <li><a href=../pages/illustrated-whist.html>Illustrated Whist</a></li> </ul> </div> </div> </div><!-- /.navbar --> </div> <div class=body> <div class=container> <div class=row> <div class=col-md-7> <h1>Bagatto, a New Static Site Generator</h1> <p class=post-info> 2020-12-10 </p> <p>The last few weeks I’ve been in a bit of a ferment of inspiration. The output of my fermentation has been <a href=https://bagatto.co/ >Bagatto</a>, a static site generator written in the Lisp <a href=https://janet-lang.org/ >Janet</a>.</p> <p>To the uninitiated: an SSG is a program for building websites. You maintain a bunch of source files—blog posts written in Markdown, for instance—and run your SSG to create a bunch of HTML out of them. You upload the html somewhere and that’s the website.</p> <p>Here’s the source of this blog: <a href=https://git.sr.ht/~subsetpark/subsetpark>https://git.sr.ht/~subsetpark/subsetpark</a></p> <h2>Background</h2> <p>Before it occurred to me to do this I was using <a href=https://github.com/gar1t/lambdapad>LambdaPad</a>, an SSG written in Erlang. The idea with LambdaPad is, you maintain an Erlang source file, <code>index.erl</code>, that defines your site in terms of a couple simple data structures. When you run LambdaPad, it will evaluate your index file and interpret the values it defines as instructions for generating your site. For the truly interested, you can view the LambdaPad version of this same site <a href="https://chiselapp.com/user/subsetpark/repository/subsetpark/tree?ci=47dd2022bc408b8a">here</a>.</p> <p>This is a very appealing model to me, for two main reasons: 1) you <em>don’t</em> need to learn a new configuration language, 2) you <em>do</em> get to take advantage of a whole programming language in defining your site.</p> <p>To take literally the first example that springs to mind, if we look at the quickstart for <a href=https://gohugo.io/getting-started/quick-start/ >Hugo</a>, a very popular program in Go for doing much the same thing, we see that one does not actually write much Go when defining a site. This sort of thing has always struck me as a bit odd; Hugo is identified very much with the language its written in—and generally SSGs are: Jekyll for Ruby, Pelican for Python, et cetera—and yet the process of building a site in Hugo involves writing to a <code>config.toml</code> file and running <code>hugo new</code> commands.</p> <p>There’s nothing inherently wrong with this approach. Hugo is no doubt a robust and reliable program, and anyone who doesn’t know a programming language, or doesn’t want to do programming when they build their website, will benefit greatly from its design. I simply don’t fall into that camp. I hate writing config files, I like programming, but more importantly, I <em>really</em> like the fact that I can use a programming language to make it <em>easier</em> to write a website that does what I want.</p> <p>The <a href=../notes/index.html>notes</a> section of this website, for instance, is also statically generated from source Markdown. But it goes through a layer of processing in the journey from Markdown to HTML, with notes being collated and cross-referenced to other notes based on their contents. In Erlang, this is accomplished by running some regexps on the note text and replacing the content strings with other Markdown links. In other words, a little basic programming.</p> <p>Nevertheless, there were a few itches that had grown over my time using LambdaPad. What’s interesting is that they all derived from the same sort of thing I’m discussing above. Even though LambdaPad is much more code-oriented than config-oriented, it still relies on <em>indirect action</em> in a number of places. Each of these places offers a degree of convenience and simplicity, but eventually became a stumbling block.</p> <p>LambdaPad, for instance, looks for a file called <code>index.erl</code> in the current directory. This is convenient because you can simply run <code>lpad-gen</code> in the current directory to build everything. Unfortunately, it presents an artificial constraint on organizing your code. If you want to manage your source files with <a href=https://github.com/erlang/rebar3>rebar3</a> you’ll want to have your Erlang source in <code>src/</code>, which means rebar3 and LambdaPad are in conflict.</p> <p>Similarly, we can see that the data specification in my LambdaPad index consists of lines like this:</p> <pre><code class=language-erl>      notes =&gt; {markdown, &quot;notes/*.md&quot;},
</code></pre> <p>That’s a key-value pair mapping an atom to a tuple of an atom and string. This is concise and easy to write. But it also doesn’t actually <em>do</em> anything; it’s just a couple literal terms. The actual mechanism of loading source files exists entirely inside of the LambdaPad package. I pass it a tagged value, giving the name of the data loader I want it to use, and everything else happens under the covers.</p> <p>Thus, the moment that I was reading on Lobsters about <a href=https://asciidoc.org/ >AsciiDoc</a> and wanted to look into how much lift it would be to use that instead of Markdown. As it happens, I couldn’t, really. The output of the <code>data/1</code> function in a LambdaPad module is not the source data to generate the site; it’s a DSL constituting instructions for generating that source data.</p> <h2>Principles for a new SSG</h2> <p>A philosophical orientation is beginning to form here. If we’re going to write <a href=https://erikwinter.nl/articles/2020/why-i-built-my-own-shitty-static-site-generator/ >yet another Static Site Generator</a>—and god knows, there are <a href=https://jamstack.org/generators/ ><em>so many of them</em></a>—can we orient ourselves around a pervasive sense of <strong>transparency</strong>? That is, to the greatest extent, how can we expose to a site author a programming environment where the inputs and the outputs of the system as a whole, and of each individual step, are entirely inspectable, observable, and extensible?</p> <p>Arguably, to do so, we need to develop some sort of theory of what the inputs and the outputs of an SSG are. So let’s say:</p> <ul> <li> <p>The inputs to an SSG are a heterogeneous collection of source data files. Many of these will be long-form posts or articles, but even those are a special case of a more general bag of attributes (like a JSON file containing the title and author’s name of your site).</p> </li> <li> <p>The output of an SSG is a list of files to be generated. A file-to-be-generated consists of exactly two things: the path of the new file, and the contents of the new file. This is an important and pleasing simplification: in a website, there are no such things as posts, or pages, or indices. There are only <code>(file path, file contents)</code> pairs. If the domain model of your site can’t be reduced to one of those, it won’t exist in your website.</p> </li> </ul> <h3>Functions</h3> <p>At this point the way forward feels pretty clear. We have two phases—the input phase and the output phase—and we know what kind of data each one should contain. If I want to provide that data as a site author, in a way that allows me to conveniently inspect and arbitrarily transform what I’m providing, the simplest method is with ordinary functions.</p> <p>This is the departure from the model I had been using in LambdaPad. Even though my <code>index.erl</code> is an Erlang file, if I were to open it in the Erlang shell and invoke my <code>data/1</code> function, I’d just get some dead terms out. On the other hand, if the terms in my <code>data/1</code> were functions which output the actual site data, then at any point I could run just those functions and see exactly what the outputs would be. And I could trivially wrap those functions in any other business logic to arbitrarily transform them as I needed.</p> <p>The same principle goes for the output phase. If the return value of my <code>site/1</code> function<sup class=footnote-ref><a href=#fn1 id=fnref1>1</a></sup> is atom and tuple values constituting a configuration language, describing which built-in file-generation tools should be called and with what inputs, then the actual output of those tools is obscured from me until it shows up in my file tree. But passing in callable, wrappable functions means that there’s no part of the process that’s off-limits.</p> <p>In other words: instead of providing a configuration language, we should provide a <em>standard library</em>. A collection of functions with a few well-defined signatures that can be easily composed and extended. And we should ensure that the signatures are transparent and simple enough that it’s trivial to write new ones that do new things.</p> <p>As an example: we saw above how to specify input files and their parsers in LambdaPad: <code>{markdown, &quot;notes/*.md&quot;}</code>. We are locked out from adding an <code>asciidoc</code> parser.</p> <p>On the other hand, if we imagine that the Markdown parser were a function, specified directly, that looked like this:</p> <pre><code class=language-erl>parse_markdown(Contents, Attributes) -&gt;
    Metadata = read_front_matter(Contents),
    maps:merge(Attributes, Metadata).
</code></pre> <p>And were specified like this:</p> <pre><code class=language-erl>notes =&gt; {loader =&gt; load_glob(&quot;notes/*&quot;),
          parser =&gt; fun parse_markdown/2},
</code></pre> <p>Then we could write a new AsciiDoc parser which ran <a href=https://asciidoctor.org/ >Asciidoctor</a> on <code>Contents</code> and merged the resulting metadata, and specify that directly as the value for <code>parser</code>.</p> <h2>Bagatto</h2> <p>This is the basic approach I’ve taken when building Bagatto: a new Static Site Generator written in Janet, which interprets a Janet file much in the same way that LambdaPad interprets Erlang.</p> <p>For instance, here’s the equivalent specification for the Notes section of this blog:</p> <pre><code class=language-clj>:notes {:src (bagatto/slurp-* &quot;notes/*.md&quot;)
        :attrs notes/parse-note
        :transform (bagatto/attr-sorter &quot;topic&quot;)}
</code></pre> <p><code>notes/parse-note</code> is a function. <code>bagatto/slurp-*</code> and <code>bagatto/attr-sorter</code> are both provided as a part of the Bagatto “standard library”, but they themselves are higher-order-functions which return other functions. So any of these values can be directly evaluated and inspected in a REPL, or wrapped to transform their output.</p> <h3>On Lisp</h3> <p>I find Janet to be tremendously well-suited to the task at hand. There are a couple reasons. Maybe the simplest is speed: unlike Erlang, there’s no heavy VM or runtime to load, so Bagatto starts up very quickly. Important for a command-line application.</p> <p>But Janet is also a Lisp, and Lisps tend to be very good at interpreting themselves without having to do too much sleight-of-hand. So it’s a natural fit for any application model where you write a program to make it run, and the application itself becomes a slightly specialized interpreter.</p> <p>It was very important to me that the author be able to assume, in the greatest number of cases, that their Janet index file would behave identically to a normal Janet program under interpretation. This extends to things like being able to manage external dependencies with <a href=https://janet-lang.org/docs/jpm.html><code>jpm</code></a>, and structure one’s modules as one would structure any other Janet package. The inherent availability of the compilation apparatus at all times makes this much more feasible.</p> <h3>Temple, the Janet template language</h3> <p>At first I was a bit disappointed to see the state of HTML templating in Janet. I had rather hoped to be able to use something like Jinja or Django templates, as that is what I’d used in the past and I wanted Bagatto to be transparent and agnostic, and not to ipose its own conventions or DSLs on a site author. However, those aren’t really available in a native way. There’s <a href=https://github.com/pyrmont/musty/ >musty</a>, which is a partial version of <a href=http://mustache.github.io/ >Mustache</a>, and there’s <a href=https://git.sr.ht/~bakpakin/temple>Temple</a>, which is Janet specific.</p> <h4>Django templates, Jinja, ERB, EEX</h4> <p>However, here’s the thing about something Django templates or Jinja: they’re actually awful. Here’s an example of a Django template I was using for notes:</p> <pre><code class=language-html>      &lt;h1&gt;{{ note.topic }}&lt;/h1&gt;
      {{ note|with_hyperlinks:all_notes|markdown_to_html }}
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;hr&gt;
    {% related_notes note all_notes %}
</code></pre> <p><code>with_hyperlinks</code> and <code>related_notes</code> are functions I defined in my <code>index.erl</code>, so it’s tremendously useful to be able to call your native code from the template. But what’s with the syntax there? Pipes I understand, though obviously that’s a shell-ism that has little to do with Erlang or HTML. But why does <code>with_hyperlinks</code> take an argument with a <code>:</code> while <code>related_notes</code> takes arguments with spaces? Maybe something to do with <code>{{ }}</code> vs <code>{% %}</code>? Truly I don’t know. Every Django template I’ve ever written has been write-once. And of course, being able to call native functions is not the same as having native syntax; Django templates, or Jinja templates for that matter, expose their own limited control flow primitives, <code>for</code> and suchlike. This is another element that I have found both underpowered and nearly impossible to remember.</p> <p>An alternative approach is presented by template languages like <a href=https://puppet.com/docs/puppet/5.5/lang_template_erb.html>ERB</a> (I’m more familiar with the Elixir version, but it’s clearly a descendent of ERB, so I’ll refer to that one instead). Here’s a snippet:</p> <pre><code>&lt;% unless @keys_trusted.empty? -%&gt;
trustedkey &lt;%= @keys_trusted.join(' ') %&gt;
&lt;% end -%&gt;
</code></pre> <p>Unlike Django templates, ERB <em>does</em> expose the full syntactic power of Ruby in your template. This is wonderful. On the other hand, this additional power and intermingling of syntaxes means that the escaping language becomes much more complex.</p> <p>Now, again: I have been writing EEX (which operates along similar principles) off-and-on for more than two years. I <em>barely</em> understand the difference between <code>&lt;% %&gt;</code> and <code>&lt;%= %&gt;</code>. The latter inserts text into the template and the former doesn’t, but that understanding doesn’t prevent me from constantly failing to understand what my templates are doing. I lay much of the blame for this on the shoulders of this family’s intermingling of escaped and plaintext within a <em>single syntactic construct</em>. You can see that above: even though <code>unless</code> and <code>end</code> form the two ends of a single syntax block, they are both contained in separate angle-brackets tags and there’s both untemplated text as well as a separate template tag between them. This sort of thing makes my head hurt.</p> <h4>Temple</h4> <p>So when I realized that Temple works differently, I was excited. The requirement to learn a new template language is well worth it because this one is much better than those.</p> <p>Here’s the equivalent to the notes snippet above in my Temple version:</p> <pre><code class=language-clj>&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-7&quot;&gt;
    &lt;h1&gt;{{ (get-in args [:_item &quot;title&quot;]) }}&lt;/h1&gt;
    {- (-&gt; (get-in args [:_item]) 
           (with-hyperlinks (args :notes)) 
           (bagatto/mmarkdown-&gt;html)) -}
  &lt;/div&gt;
&lt;/div&gt;
{% (def related-notes (all-related (args :notes) (args :_item)))
   (unless (empty? related-notes) (print &quot;&lt;hr&gt;&quot;))
   (print-related related-notes (args :_item) (args :root)) %}
</code></pre> <p>We can see that the <code>&lt;h1&gt;</code> tag has the same simple <code>{{ }}</code> interpolation. The value of the expression between the curly braces is interpolated directly into the HTML. However, we get to use the exact same Janet syntax rather than this quasi-Python-syle interloper.</p> <p>However. Let’s turn to the bottom of the template where we have a more complicated piece of logic. It too uses native Janet syntax. But it is crucially different from ERB. In this piece of Janet, <em>everything</em> is contained within a single <code>{% %}</code> delimiter. Syntactically it is whole and easy to read. You could copy it out of this file and into the interpreter and it would parse perfectly. That’s because Temple doesn’t need to constantly flip back and forth from tag to text in order to interpolate text from within Janet code. It simply uses <code>print</code>.</p> <p><code>print</code>! When Temple evaluates a template, it inserts everything into the template that’s written out to stdio! What a brilliant idea! I immediately understand what is being output and what isn’t. And I don’t need to break up my syntax into unconnected blocks.</p> <p>What a pleasure. Having rewritten all my Django templates into Temple, I have such a greater degree of confidence in them. I can update them much more easily. I wish I could do the same for my EEX templates, but I think my coworkers would object.</p> <h2>Transparent, extensible</h2> <p>I hope I’ve done a good enough job of communicating the values and philosophy of Bagatto. I feel quite good about it. I feel more productive using it, and I feel that it is a faithful expression of the rationale that I’ve laid out here. Perhaps you might feel the same.</p> <section class=footnotes> <ol> <li id=fn1> <p>LambdaPad expects the presence of two functions in your <code>index.erl</code>: <code>data/1</code> and <code>site/1</code>. These are expected to return, respectively, the specifications for the input to the site generation phase and the output of the site generation phase (ie, the generated files and their contents). <a href=#fnref1 class=footnote-backref>↩</a></p> </li> </ol> </section> </div> <div class=col-md-3> <h3>Recent Posts</h3> <table class=recent-posts> <tr> <td style=white-space:nowrap>2022-02-19</td> <td><a href=../posts/a-specification-of-a-note-taking-program.html>A Specification of a Note-Taking Program</a></td> </tr> <tr> <td style=white-space:nowrap>2021-03-20</td> <td><a href=../posts/algorithms-im-proud-of-fill.html>Algorithms I'm Proud Of: Fill</a></td> </tr> <tr> <td style=white-space:nowrap>2020-12-10</td> <td><a href=../posts/bagatto-a-new-static-site-generator.html>Bagatto, a New Static Site Generator</a></td> </tr> <tr> <td style=white-space:nowrap>2020-11-22</td> <td><a href=../posts/a-regular-simplification-of-offenbacher-schrift.html>A Regular Simplification of Offenbacher Schrift</a></td> </tr> <tr> <td style=white-space:nowrap>2020-08-20</td> <td><a href=../posts/mariglia.html>Mariglia</a></td> </tr> </table> </div> </div> </div> </div> <hr> <div class=footer>Built with <a href=https://bagatto.co>Bagatto.</a></div> </div> </div> </div> </body> </html> 