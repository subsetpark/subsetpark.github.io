<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>Subset Park: On the Appeal of Lisp</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content="{loglevel, debug}"><meta name=author content="Z. D. Smith"><link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=../assets/bootstrap.min.css rel=stylesheet><link href=../assets/bootstrap-responsive.min.css rel=stylesheet><link href=../assets/styles.css rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/styles/ascetic.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=alternate type=application/rss+xml title=RSS href=../feed.xml></head> <body> <div class=container> <div class=row> <div class=col-md-1></div> <div class=col-md-10> <div class=masthead> <div class=navbar> <div class=navbar-inner> <div class=container> <ul class=nav> <li class=active><a href=../index.html>Home</a></li> <li><a href=../posts/index.html>Posts</a></li> <li><a href=../notes/index.html>Notes</a></li> <li><a href=../pages/about.html>About</a></li> <li><a href=../pages/illustrated-whist.html>Illustrated Whist</a></li> </ul> </div> </div> </div><!-- /.navbar --> </div> <div class=body> <div class=container> <div class=row> <div class=col-md-7> <h1>On the Appeal of Lisp</h1> <p class=post-info> 2020-05-17 </p> <p>I've started playing around with a new language, the first time in a while: <a href=https://janet-lang.org/ >Janet</a>, a Lisp-alike whose syntax and standard library is most directly influenced, it seems to me, by Clojure, but is written in C and starts up a hell of a lot more quickly---lending it well to a niche that I've idly liked to fill for a while: that of writing performant, small utilities for the command line (if I wanted to write Lisp on a server, I presumably would just write Clojure directly, where the startup time of the JVM is not really a problem).</p> <p>I say &quot;Lisp-alike&quot; because---appearances very much aside, as Janet looks like this:</p> <pre><code>(use joy)

(defn home [request]
  (text/plain &quot;You found joy!&quot;))

  (def routes [[:get &quot;/&quot; home]])

  (def handler (handler routes))

  (server handler 8000)
</code></pre> <p>and I think most people would say: parentheses, <code>def/defn</code>, prefix notation, it's a Lisp, let's go home---there is a very vocal contingent <em>around</em> that will go to extreme pains to point out that <strong>Janet is not a Lisp</strong>. <em>qv</em>:</p> <blockquote> <p>I never thought I'd see a Lisp without lists. Oh wait, I didn't because this isn't a Lisp.</p> </blockquote> <p>and</p> <blockquote> <p>Lisp is a specific implementation of symbolic and list processing with specific shapes of data structures, names of functions and their semantics, treatment of Boolean conditions, syntax, and everything else.</p> </blockquote> <p>I think some of the elements of the latter list of criteria are potentially misleading, as Janet <em>does</em> have those, so let's focus on what it conspicuously doesn't have: lists.</p> <p>Not &quot;lists&quot; in the generic sense of &quot;ordered primitive data structures&quot;, but &quot;lists&quot; in the specific sense of &quot;linked lists&quot;. Janet hasn't got them; its two generic sequential data structures, the <em>array</em> and the <em>tuple</em>, are based on C arrays, can be O(1) indexed into rather than processed as pairs of cons cells. And because they're <em>not</em> implemented as pairs of cons cells, the <code>car</code>/<code>cdr</code> set of functions is not available, and the paradigm of handling the head of a list and recursing on its tail is not the default way to handle data structures.</p> <p>I will not spend too much time dwelling on this distinction, or how asinine I find this kind of terminological essentialism. But it <em>has</em> got me thinking about the eternal mystic appeal of Lisps. For a long time now I've wanted to sharpen my Lisp (or S-expression handling, or quote-unquote-quasiquoting) sensibilities. I've always half-hoped for the opportunity to write LFE or Clojure in production, and I've played on my own time with a half-dozen Scheme implementations in the past.</p> <p>What's the appeal of Lisp? If Janet appeals to me, it's clearly <em>not</em> cons cells and linked lists. And it's not <em>exactly</em> macros, or just <em>any</em> macros, as I write syntactic macros all day long in Elixir and while I appreciate them for what they give me, they don't seem to have scratched the itch that has me peeking over the fence at the world of Lisp.</p> <p>Let's consider Elixir at greater length, as Elixir macros and Lisp macros might be closest to a minimal pair within my own experience[^nim_macros]. Elixir's macro system is quite powerful, providing hygienic syntactic macros which can be leveraged for common-or-garden code generation up to full-blown DSLs.</p> <p>[^nim_macros]: I spent a good while writing Nim, but: neither was it as long as I've written Elixir, nor did <a href=https://nim-by-example.github.io/macros/ >macros</a> or their cousins, templates, play nearly the same role in my use of the language as they do in Elixir and they do in the hands of a seasoned <a href=https://letoverlambda.com/ >Let Over Lambda</a>er. Plus, you can do more functional programming in Lisp (and <em>only</em> functional programming in Elixir).</p> <p>As an example, we can easily get the AST of a function definition (here the trivial identity function) as an AST data structure, expressed as an ordinary Elixir data structure:</p> <pre><code class=language-ex>iex(1)&gt; quote do
...(1)&gt;   def id(x), do: x
...(1)&gt; end
{:def, [context: Elixir, import: Kernel],
 [{:id, [context: Elixir], [{:x, [], Elixir}]}, [do: {:x, [], Elixir}]]}
</code></pre> <p>We can operate on this data structure however we like at compile time, renaming things, replacing its contents, <em>et cetera</em>. And indeed macros are quite common (relatively speaking) in Elixir; the <code>use</code> directive which is found at the top of many modules calls its target module's <code>__using__</code> macro, which can inject arbitrary code into the calling module: features as simple as importing a few other modules, saving you a couple lines of code, to providing default implementations of functions, registering attributes, and more.</p> <p>Inside of a <code>quote</code> block we can pretty easily interpolate values from the environment, with <code>unquote</code>:</p> <pre><code class=language-ex>iex(1)&gt; y = :ok
:ok
iex(2)&gt; quote do
...(2)&gt;   def it(_x), do: unquote(y)
...(2)&gt; end
{:def, [context: Elixir, import: Kernel],
 [{:it, [context: Elixir], [{:_x, [], Elixir}]}, [do: :ok]]}
</code></pre> <p>And yet there is something different between this and its Janet equivalent:</p> <pre><code class=language-clj>janet:1:&gt; (def y :ok)
:ok
janet:2:&gt; ~(defn id [_x] ,y)
(defn id [_x] :ok)
</code></pre> <p>It's not just that the operation is easier, in the sense of requiring less extra typing. While functionally equivalent, the syntax of Elixir is almost infinitely more complex than that of a Lisp (any Lisp), in the sense that there <em>is</em> some. And this shows up in the return values of each quote operation: Elixir's looks quite different indeed the code that was written to produce it, whereas Janet's is as close as possible.</p> <p>No duh, says the reader, you have just discovered the principle of <a href=https://en.wikipedia.org/wiki/Homoiconicity>homoiconicity</a>. Not quite, though. To be homoiconic a language must represent its AST in data structures primitive to the language itself. Elixir manifestly does this; an Elixir AST node is an Elixir tuple with three elements. There is a difference, which might be strictly perceptual, but since the process I'm interested in is the one happening in my own mind, you'll forgive me if I treat it as material. There is a thing that happens (or promises to happen, or seems like it would happen) when the syntax of a language is sufficiently minimal that the language <em>as written by humans</em> is almost visually indistinguishable from the representation of the data structures that encode an instance of that syntax.</p> <p>There's another trick here: Lisp has <em>symbols</em>. These are truly mysterious and have even less of an analogue in other languages that I've used.</p> <p>Let's return to the Elixir example above. Modulo some reader sugar, every alphabetical object in that AST is encoded as an <em>atom</em>, one of the core data types. Atoms are lovely and every language should have them, or something like them: human-readable constants whose only value is their identity. Great for pattern-matching against. Individisble (as the name suggests).</p> <p>Janet has them too; there they're called <em>keywords</em>, and they have the same semantics. They happen to be represented the same way, as a colon followed by a string of characters, as in <code>:ok</code> above. But evaluation #2 of the janet interpreter demonstrates a distinction between two primitive types: <code>:ok</code> is a keyword, but the other alphabetical elements don't have any colons in front of them because they aren't keywords, they're symbols.</p> <p>In Janet, as, I would guess, in any other Lisp, the <em>type</em> of the unevaluated words of the source code is <em>symbol</em>. Is that even expressible in most other languages? What is the <em>type</em> of <code>def id(x), do: x</code>? I can tell you the type of the AST that you get when it's evaluated as source code. And I can tell you what it <em>does</em> when that AST is evaluated by the Elixir compiler. On the other hand, I can tell you exactly what the type of <code>(use joy)</code> is, in Janet: it's a tuple of two symbols[^tuple-not-list].</p> <p>[^tuple-not-list]: Of course, in a proper Lisp, it would be a list, not a tuple. Let us never forget.</p> <p>Is this a meaningful distinction? Is it really more meaningful to talk about the actual text <code>(use joy)</code> as though it were data? Or is it a category mistake brought on by the fact that the Janet parser happens to use that text as both a meaningful input as well as the representation of its output?</p> <p>Parsing is only one step in the journey, of course. Symbols don't only have a textual representation; they also have an evaluation. And in reality, keywords are very similar to symbols. Sometimes you can just say that a keyword is a special kind of symbol that starts with a colon. But keywords evaluate to <em>themselves</em>, whereas symbols evaluate to... <em>something else</em>, at least by default.</p> <p>So what? So do references in C, and I don't find myself gravitating towards C in search of mystical experiences.</p> <p>We're getting kind of swimmy here. And implementation-specific. The point is that these questions are <em>much closer to the surface</em> in Lisp than in Elixir or any other macro-ful language I've used. The presence of symbols in the primitive inventory of this language induces in the programmer the sensation of being at all times suspended in an infinite cycle of evaluation, which can always be trivially advanced some number of steps.</p> <h2>A caveat</h2> <p>I want to stress at this point that I haven't written any of the above in an attempt to demonstrate why Janet in particular or Lisp in general is <em>better</em> than Elixir, or even why Lisp macros are <em>better</em> than Elixir macros. I love Elixir and never find myself cursing the distance imposed between me and its AST by a more complex syntax and the absence of symbols as a first-class data type.</p> <p>There is, of course, a <a href=https://letoverlambda.com/ >school</a> that quite sincerely believes that</p> <blockquote> <p>Macros are what make lisp the greatest programming language in the world.</p> </blockquote> <p>If I am on my way there, I certainly haven't been convinced yet. It's quite important, whenever waxing philosophical about the sublime pleasures of metaprogrammic, to draw a clear distinction between the utility of such a thing and the way it makes your brain feel. Indeed, when I consider that the standard pitch for the <em>superiority</em> of macros is that it lets you write languages to solve your problem instead of programs, I get awfully worried. I quite like being able to reason through code that I haven't written, and a good first step towards that goal is everybody settling on writing their code in roughly the same codebase.</p> </div> <div class=col-md-3> <h3>Recent Posts</h3> <table class=recent-posts> <tr> <td style=white-space:nowrap>2022-02-19</td> <td><a href=../posts/a-specification-of-a-note-taking-program.html>A Specification of a Note-Taking Program</a></td> </tr> <tr> <td style=white-space:nowrap>2021-03-20</td> <td><a href=../posts/algorithms-im-proud-of-fill.html>Algorithms I'm Proud Of: Fill</a></td> </tr> <tr> <td style=white-space:nowrap>2020-12-10</td> <td><a href=../posts/bagatto-a-new-static-site-generator.html>Bagatto, a New Static Site Generator</a></td> </tr> <tr> <td style=white-space:nowrap>2020-11-22</td> <td><a href=../posts/a-regular-simplification-of-offenbacher-schrift.html>A Regular Simplification of Offenbacher Schrift</a></td> </tr> <tr> <td style=white-space:nowrap>2020-08-20</td> <td><a href=../posts/mariglia.html>Mariglia</a></td> </tr> </table> </div> </div> </div> </div> <hr> <div class=footer>Built with <a href=https://bagatto.co>Bagatto.</a></div> </div> </div> </div> </body> </html> 