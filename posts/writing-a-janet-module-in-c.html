<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>Subset Park: Writing a Janet Module in C</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content="{loglevel, debug}"><meta name=author content="Z. D. Smith"><link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=../assets/bootstrap.min.css rel=stylesheet><link href=../assets/bootstrap-responsive.min.css rel=stylesheet><link href=../assets/styles.css rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/styles/ascetic.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=alternate type=application/rss+xml title=RSS href=../feed.xml></head> <body> <div class=container> <div class=row> <div class=col-md-1></div> <div class=col-md-10> <div class=masthead> <div class=navbar> <div class=navbar-inner> <div class=container> <ul class=nav> <li class=active><a href=../index.html>Home</a></li> <li><a href=../posts/index.html>Posts</a></li> <li><a href=../notes/index.html>Notes</a></li> <li><a href=../pages/about.html>About</a></li> <li><a href=../pages/illustrated-whist.html>Illustrated Whist</a></li> </ul> </div> </div> </div><!-- /.navbar --> </div> <div class=body> <div class=container> <div class=row> <div class=col-md-7> <h1>Writing a Janet Module in C</h1> <p class=post-info> 2020-08-17 </p> <p>After a long time managing to stay at a safe, high level in my adventures with <a href=https://janet-lang.org/ >Janet</a>, I've decided it's finally time for me to descend into the world of <a href=https://janet-lang.org/capi/index.html>native modules</a>. To quote the manual:</p> <blockquote> <p>One of the fundamental design goals of Janet is to extend it via the C programming language, as well as embed the interpreter in a larger program. To this end, Janet exposes most of its low level functionality in well defined C API.</p> </blockquote> <p>What this means is that Janet has a robust and extensive C API that you can use to write C code that can be imported as a Janet function, and jpm, the Janet build tool, has the ability to compile that code and make it available in a pure-Janet context. This has two main applications:</p> <ul> <li>Implementation of algorithms or data structures with a finer grain of control, and better performance, than if they were written in Janet;</li> <li>Making any existing C-compatible library available to the Janet ecosystem.</li> </ul> <p>This second application is particularly common. The <a href=https://github.com/janet-lang/sqlite3>sqlite</a>, <a href=https://github.com/andrewchambers/janet-pq>postgres</a>, and <a href=https://github.com/pyrmont/markable>markdown</a> libraries are all written this way. And now it's my turn. Ultimately, I'd like to write bindings for Janet to the <a href=https://www.jsoftware.com/#/ >J Programming Language</a>, using the same native module technique. First, though, I have to remember how to write C and write a toy Janet module.</p> <h2>a simple Janet C module</h2> <p>There's a fair amount of documentation in the Janet manual about writing a C module, including some reference code to start with. I figured it would be worthwhile to get a <em>little</em> more detailed, recording the things I've learned hacking a module together, for those who---like me---never write code as low-level as C, or with manual memory management, in their ordinary programming practice.</p> <p>The module will expose a single function, <code>concat</code>, which will join two strings together. This is available in the standard library of course, but I found it to be a good demo function since it includes three major areas:</p> <ul> <li>handling arguments from, and returning them to, Janet</li> <li>ordinary procedural business logic</li> <li>memory allocation</li> </ul> <h2>programming environment</h2> <p>I don't have a terrifically built-out C programming environment. However, one feature I do have set up is the [clangd][] language server. It's a little out of scope of this article to explain the language server protocol, but if you're starting from zero I think clangd is a good starting point. In particular, it automatically compiles my C file and lints my buffer with the output. That makes for a very rapid feedback loop.</p> <h2>concat.c</h2> <h3>including the header</h3> <pre><code class=language-plaintext>#include &lt;janet.h&gt;
</code></pre> <p>The <code>janet.h</code> header file exposes the entire Janet C API: all the functions for handling Janet datatypes, exposing C functions as Janet functions, managing garbage collection, et cetera.</p> <p>By default this will produce a compile error. When building with jpm, the build tool will ensure the correct compiler flags are set so that that header is available. However, to get clangd to be able to compile, you need to point it to the location of the file. I added a file <code>compile_flags.txt</code>, which clangd will recognize, with the contents:</p> <pre><code class=language-plaintext>-I/usr/include/janet
</code></pre> <p>Thus when it compiles <code>concat.c</code>, it will automatically include Janet's headers directory.</p> <h3>defining the <code>concat</code> function</h3> <pre><code class=language-c>static Janet concat(int32_t argc, Janet *argv) 
</code></pre> <p>This is the declaration for the definition of the function <code>concat</code>. It's important to understand the function signature as all Janet functions defined in C will have the same signature.</p> <p><code>concat</code> takes two arguments:</p> <ul> <li><code>argc</code>, an integer containing the number of arguments it was called with;</li> <li><code>argv</code>, a Janet array containing all of its arguments.</li> </ul> <h2>Janet types in C</h2> <p>To quote the manual:</p> <blockquote> <p>Janet has several built-in fundamental data types. These data types are the bread and butter of the Janet C API, and most functions and macros in the API expect at least some of their arguments to be of these types. However, as Janet is a dynamically typed language, Janet internally uses a boxed representation of these types, simply called <code>Janet</code>.</p> </blockquote> <p>To elaborate, we can say that under the hood, there is a <em>three-part continuum</em> of types spanning from pure C to pure Janet.</p> <p>At the bottom are the pure C types; to perform the basic underlying business logic of your function, you will use ordinary C logic. For instance, since we're dealing with strings, we'll be dealing with the <code>uint8_t *</code> type.</p> <p>In the middle are the <code>Janet&lt;foo&gt;</code> types; <code>JanetArray</code>, <code>JanetKV</code>, et cetera. For complex data structures like arrays and tables, those types are C structs. For simpler data structures that can be directly represented in C, those types are aliases to raw C types. Strings are of the simpler case; <code>JanetString</code> is an alias to <code>const uint8_t *</code>. However, it's useful to think of this level as a consistent set of types, because all the business logic functions exposed in the Janet C API target these types. And because a <code>JanetString</code> is <code>const</code>, it's useful to have a distinction between mutable <code>uint8_t *</code> and <code>const uint8_t *</code>.</p> <p>At the top is the <code>Janet</code> type. Everything going in and out of the C interface will be of this type. It's obviously more difficult to work on the underlying values inside of the C, but it performs the crucial translation between the static typing of C and the dynamic typing of Janet.</p> <p>In other words, there is a distinct purpose for each level:</p> <ul> <li>C types: all Janet-agnostic business logic/interoperation with other compatible libraries</li> <li><code>Janet*</code> types: C representations of each Janet data type with accompanying type-specific business logic</li> <li><code>Janet</code>: receiving and returning arguments between Janet and C</li> </ul> <h2><code>concat</code></h2> <p>Thus, <code>argv</code> is a <code>Janet</code>, though conventionally we know it will contain a <code>JanetArray</code>.</p> <p>The return type of <code>concat</code> is also <code>Janet</code>, because we'll box our return value after we've constructed it.</p> <pre><code class=language-c>{
  janet_fixarity(argc, 2);
  JanetString s1 = janet_getstring(argv, 0);
  JanetString s2 = janet_getstring(argv, 1);

...
</code></pre> <p>There's some boilerplate in the argument handling. Because we should always have two arguments, we call <code>janet_fixarity</code> to validate that it was called with two arguments and will fail otherwise.</p> <p>We then call <code>janet_getstring</code>, which will do the work of unwrapping <code>argv</code>, getting an element, and then unwrapping that and validating its type. At this point we have moved below the Janet layer into the static types of the Janet C API.</p> <pre><code class=language-c>...

  int s1_length = janet_string_length(s1);
  int s2_length = janet_string_length(s2);
  int32_t strlength = s1_length + s2_length;

...
</code></pre> <p>To get the total length of the result of concatenation, we'll just add the size of the two arguments together. Having unwrapped the arguments, we can use the Janet datatype business logic exposed in <code>janet.h</code>, in this case the function <code>janet_string_length()</code>.</p> <pre><code class=language-c>...

  char *newstring = janet_smalloc(strlength);

...
</code></pre> <p>To create a new string, we allocate one on the heap.[^vla]</p> <p>[^vla]: Here's something I didn't know about C; modern C has support for dynamically allocating on the stack as well as the heap. <br> <br> If I had written <code>char newstring[strlength];</code> instead, the C compiler would have created a <a href=https://en.wikipedia.org/wiki/Variable-length_array>variable-length array</a> and it would have allocated a new string to the stack (with all of the attendant hazards and benefits of stack allocation). <br> <br> My thanks to <a href=https://github.com/andrewchambers>Andrew Chambers</a> for that info!</p> <p>It's important to remember that any term produced in pure Janet is subject to garbage collection and thus doesn't have to be manually allocated or freed. In the C API, the garbage collector doesn't, by default, have any awareness of memory allocated with the built-in function <code>malloc</code>, and thus will leak if not manually freed. <code>janet_smalloc</code> (the <code>s</code> stands for &quot;scratch&quot;) behaves just like <code>malloc</code> <em>except</em> it registers the allocated memory with the GC, ensuring it will be freed[^gc]. Otherwise, allocating the new string is performed the same as in vanilla C.</p> <p>[^gc]: There are some details about <em>when</em> a C-allocated piece of memory will be freed that aren't relevant to simple invocations like this, but in C functions that might call other Janet functions, there may well be more detailed memory management necessary.</p> <pre><code class=language-c>...

  int i;
  for (i = 0; i &lt; s1_length; i++) {
    newstring[i] = s1[i];
  }

  for (i = 0; i &lt; s2_length; i++) {
    newstring[i + s1_length] = s2[i];
  }

...
</code></pre> <p>Here we actually populate the new string. We are &quot;below&quot; the Janet datatypes' level here, working with normal C strings.</p> <pre><code class=language-c>...

  JanetString res = janet_string((const uint8_t *)newstring, strlength);

...
</code></pre> <p>Once the string has been constructed, we prepare the return value by &quot;ascending&quot; the type layers. <code>janet_string()</code> takes a <code>const uint_ *</code> and returns a JanetString: this is a bit confusing, because those are the same type. However, <code>janet_string()</code> also does a bunch of background memory management and hashing and stuff. This is why it's good to maintain a conceptual distinction between <code>const uint8_t *</code> and <code>JanetString</code>.</p> <p>This also includes a manual cast of <code>newstring</code> to a <code>const</code> type. This is safe for us to do as we know we won't edit the string again after that cast.</p> <pre><code class=language-c>...

  janet_sfree(newstring);

...
</code></pre> <p><code>janet_smalloc()</code> has a companion function, <code>janet_sfree()</code>, which frees the allocated memory. I don't believe this line is strictly necessary, because the memory will be GCed, but we can make the GC's job a little easier and be slightly more efficient by manually freeing it once we know we're finished with <code>newstring</code>. The creation of the JanetString allocates new memory, so <code>newstring</code> is not going to be used after that.</p> <pre><code class=language-c>...

  Janet wrapped = janet_wrap_string(res);
  return wrapped;
}
</code></pre> <p><code>janet_wrap_string()</code> goes from the middle layer to the top layer, <code>Janet</code>, boxing the static type with a dynamic one.</p> <p>Finally, we return the boxed element.</p> </div> <div class=col-md-3> <h3>Recent Posts</h3> <table class=recent-posts> <tr> <td style=white-space:nowrap>2022-02-19</td> <td><a href=../posts/a-specification-of-a-note-taking-program.html>A Specification of a Note-Taking Program</a></td> </tr> <tr> <td style=white-space:nowrap>2021-03-20</td> <td><a href=../posts/algorithms-im-proud-of-fill.html>Algorithms I'm Proud Of: Fill</a></td> </tr> <tr> <td style=white-space:nowrap>2020-12-10</td> <td><a href=../posts/bagatto-a-new-static-site-generator.html>Bagatto, a New Static Site Generator</a></td> </tr> <tr> <td style=white-space:nowrap>2020-11-22</td> <td><a href=../posts/a-regular-simplification-of-offenbacher-schrift.html>A Regular Simplification of Offenbacher Schrift</a></td> </tr> <tr> <td style=white-space:nowrap>2020-08-20</td> <td><a href=../posts/mariglia.html>Mariglia</a></td> </tr> </table> </div> </div> </div> </div> <hr> <div class=footer>Built with <a href=https://bagatto.co>Bagatto.</a></div> </div> </div> </div> </body> </html> 