<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>Subset Park: Some Preliminary Thoughts About a New Card Game Website</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content="{loglevel, debug}"><meta name=author content="Z. D. Smith"><link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=../assets/bootstrap.min.css rel=stylesheet><link href=../assets/bootstrap-responsive.min.css rel=stylesheet><link href=../assets/styles.css rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/styles/ascetic.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=alternate type=application/rss+xml title=RSS href=../feed.xml></head> <body> <div class=container> <div class=row> <div class=col-md-1></div> <div class=col-md-10> <div class=masthead> <div class=navbar> <div class=navbar-inner> <div class=container> <ul class=nav> <li class=active><a href=../index.html>Home</a></li> <li><a href=../posts/index.html>Posts</a></li> <li><a href=../notes/index.html>Notes</a></li> <li><a href=../pages/about.html>About</a></li> <li><a href=../pages/illustrated-whist.html>Illustrated Whist</a></li> </ul> </div> </div> </div><!-- /.navbar --> </div> <div class=body> <div class=container> <div class=row> <div class=col-md-7> <h1>Some Preliminary Thoughts About a New Card Game Website</h1> <p class=post-info> 2020-08-16 </p> <p>For the past month and a half or so, I’ve been working on a new software system for playing card games online. If you’d like to follow along it’s being hosted on <a href=https://sr.ht/~subsetpark/tamerlane/ >sourcehut</a>.</p> <p>The idea came to me when I was talking with a friend who shares two notable characteristics with me: 1) he is a computer programmer; 2) he’s an enthusiast of obscure traditional card games. He was implementing a new card game on <a href=https://boardgamearena.com/ >Board Game Arena</a>, which is more or less the best that you can currently do if you want to build a new card game that can be played online and don’t want to implement the entire site from scratch. It’s a generic board games/card games site which has a “studio” feature, where developers can upload their own logic which describes a new game. It’s also, from where I sit, a pretty poor experience: you need to write your game in PHP, and you need to upload it by FTP. It’s a little antiquated, in other words.</p> <p>Hearing about the developer experience I had the sudden inspiration of a site that worked on the Slack installable apps model instead: one that exposed the generic bones of interaction with a deck of cards, but where you as the developer wrote a simple JSON API to describe the actual game, and installed the game simply by pointing the site at your callback URL. In other words, you could write the game itself in whatever language you liked, and only had to spin up a new web server rather than using anyone’s crufty old library.</p> <p>I called it Tamerlane, being the first word that popped into my head. The viability and suitability of this model as a product aside<sup class=footnote-ref><a href=#fn1 id=fnref1>1</a></sup>, I thought I’d go into some detail about how I’ve been building it.</p> <p>In the Tamerlane model, there’s a central <strong>game server</strong>, which all users interact with, and which maintains the state of all users and ongoing games. It in turn has entries for some number of heterogeneous independent <strong>rules servers</strong>. In particular, every ongoing game is pointed at a single rules server, which acts as the source of truth for the transformations of game state for that game.</p> <p>The game, at any point, consists of a blob of state, for example:</p> <pre><code class=language-clj>{:meta {:high_bid {:player &quot;North&quot; :bid {...}}
	    :not_passed @{:North true :South true :East true :West true}}
 :phase &quot;bid&quot;}
</code></pre> <p>At any given moment—and I think we can make this assumption for any card game—the game state is static and waiting for the next <strong>player action</strong>. This could be making a bid, discarding a card, playing a card. The entire function of any rules server is to accept a POST request to a single endpoint—let’s call it <code>/next</code>—with a description of the game state, and the player action, and to return the updated game state. The only thing left required to drive the game engine is to also specify any <strong>side effects</strong> that need to happen as a result of game state changes. This includes things like updating player information displays, showing user prompts, and ultimately ending the game.</p> <p>This leads to an interaction model like the following:</p> <pre><code class=language-plain>+---------+                +-------+                             +-------+
| Player  |                | Game  |                             | Rules |
+---------+                +-------+                             +-------+
     |                         |                                     |
     | Start new game          |                                     |
     |------------------------&gt;|                                     |
     |                         |                                     |
     |                         | GET /init?players=North,South       |
     |                         |------------------------------------&gt;|
     |                         |                                     |
     |                         |{&quot;phase&quot;: &quot;draw&quot;,                    |
     |                         | &quot;effects&quot;: [{&quot;event&quot;: &quot;prompt_draw&quot;,|
     |                         |              &quot;player&quot;: &quot;North&quot;}]}   |
     |                         |&lt;------------------------------------|
     |                         |                                     |
     | &lt;render draw modal&gt;     |                                     |
     |&lt;------------------------|                                     |
     |                         |                                     |
     | &lt;select a card&gt;         |                                     |
     |------------------------&gt;|                                     |
     |                         |                                     |
     |                         | POST /next                          |
     |                         |   {&quot;phase&quot;: &quot;draw&quot;,                 |
     |                         |    &quot;action&quot;: {&quot;name&quot;: &quot;draw&quot;,       |
     |                         |               &quot;player&quot;: &quot;North&quot;,    |
     |                         |               &quot;value&quot;: {&quot;rank&quot;: 1, &quot;suit&quot;: &quot;hearts&quot;}}}
     |                         |------------------------------------&gt;|
     |                         |                                     |
</code></pre> <p>In other words, the rules server is entirely stateless. It expects everything it needs in order to calculate game state is included in the <code>POST</code> to <code>/next</code>. Secondarily, the meat of the game interaction will be in the effects system: it’s up to the game server to expose an inventory of effects that:</p> <ol> <li>is small enough to be obvious to a rules developer;</li> <li>can be mapped to rich user experience effects so that the game server can expose an enjoyable and suggestive UI;</li> <li>can cover all, or nearly all, of the types of actions and effects that actually happen during the play of a game of cards.</li> </ol> <p>It’s fairly obvious that this system will live or die on the strength of the rules callback API it exposes. We need to design a DSL that rules developers can express both game state and game effects in that is expressive, simple, and elegant.</p> <p>To that end I started by writing a rules server, and thinking about the most natural way that I, as a rules developer, would want to statelessly implement the rules of an entire card game. That server is <a href=https://git.sr.ht/~subsetpark/whist>part of the Sourcehut project</a> and implements (at time of writing, nearly all of) the game of <a href=https://www.pagat.com/auctionwhist/bidwhist.html>Bid Whist</a>. Part of the developer proposition of this system is that you can write a rules engine in whatever language you like, so this server is written in the LISP <a href=https://janet-lang.org/ >Janet</a>. It’s been an effective way to work out what the most expressive and simple DSL would be for communicating everything that goes on in a card game, and hopefully when it’s all finished will also be a useful reference implementation of a rules server.</p> <p>I’d like, obviously, to have as few types of things as possible. Thus, here’s my current ontology; all of the entities you can describe and manipulate in order to drive any kind of card game:</p> <ul> <li><em>cards</em>: objects recognized by the system as cards, with suit and rank.</li> <li><em>players</em>: entities that correspond to users and can be referred to by ID.</li> <li><em>hands</em>: ordered lists of cards, one for each player.</li> <li><em>stacks</em>: named places on the table that can hold one or more cards. For instance, in Bid Whist there’s only a single stack, called <code>trick</code>, which is where players play to.</li> <li><em>infos</em>: named infoboxes which each track an individual piece of information that make up the game’s state. For instance, in Bid Whist there’s an infobox for each team’s score, as well as one for the number of tricks that each player has taken during the current hand. These would more naturally be called <em>counters</em> if they only held numerical information, which they might end up doing.</li> <li><em>decorations</em>: arbitrary named pieces of text which the rules server can set on each player. For instance, in Bid Whist these are used to display which player is bidding, what each player’s most recent bid is, and so on.</li> <li><em>prompts</em>: objects representing which player are allowed to move at any point and what their options are. For instance, in Bid Whist, during bidding, each player is prompted in turn to select one of the set of bids which is higher than the current bid, or to pass.</li> <li><em>actions</em>: the result of a player responding to a prompt. Every call to <code>/next</code> involves a single action, and thus the response always describes the results of that action.</li> </ul> <p>The <strong>game state</strong> consists of the stacks and the infoboxes; it’s provided to the rules server in a call to <code>/next</code> and whatever the rules server includes at <code>&quot;state&quot;</code> in its response will be the new state.</p> <p>It’s important to note that the total contents of the game state, however, is completely up to the rules developer. For instance, in the Bid Whist implementation, the rules server sets and maintains a <code>meta</code> attribute that it uses to keep track of the current highest bid, or what contract was selected.</p> <p>In addition to the game state, the only other content in the rules server response is the game <strong>effects</strong>. This essentially covers the specialized areas of interaction with the game that would be onerous to maintain in a giant state blob. Therefore, effects include:</p> <ul> <li>setting a player decoration</li> <li>clearing a player decoration</li> <li>setting a player prompt</li> <li>describing player actions like drawing and discarding</li> </ul> <p>In particular, treating player draws and discards as effects means that the rules server doesn’t need to keep track of the contents of the deck, make sure the cards have been shuffled, specify the contents of player hands, and so on. This is making the bet that there is a sufficiently general definition of drawing and discarding that can be relied on by the majority of games.</p> <p>On the other hand, it doesn’t seem that there is <em>any</em> sufficiently general definition of <em>points</em> that can be relied on in the same way. Bid Whist, for instance, involves two fixed teams, tracking the tricks taken over the course of a single hand, the outcome of which impacts the team scores tracked over the course of multiple hands. Slovenian Tarok, on the other hand, has four individual players, who sometimes (but not always) form teams for the duration of a single hand, and track the number of points captured within that hand which then impact the individual scores tracked over the course of multiple hands. It doesn’t seem that there’s some concept of teams, tricks, card points or game points which is generalizable at all. Thus the specific arrangement of scores is a part of the state—the infoboxes—and is managed directly by the rules engine however the developer sees fit.</p> <p>The other program which currently exists is the <strong>game server</strong>. That is, the program which you will ultimately interact with when you go to <code>https://toulemonde.cards</code>; the server which you’ll have an account on, create tables on, invite your friends to, and so on.</p> <p>This so far takes the form of an Elixir application which currently does little aside from interact directly with the only rules server it knows about. It can spin up a new GenServer and maintain game state by conveying user input to the rules server and interpreting the response. The key, of course, is that it needs to be completely agnostic of what it’s passing back and forth; it needs to understand the business of card playing well enough to render a compelling user interface to a human player, but simultaneously encode no assumptions whatsoever about how any particular card game works.</p> <p>To this end I’ve found it surprisingly useful to simply write a simple <code>Mix.Task</code> CLI that prompts for user input and passes it back to the rules server. Even just the task of rendering a compelling text-based view of the game board<sup class=footnote-ref><a href=#fn2 id=fnref2>2</a></sup> is a fairly good test of the primitives and effects system.</p> <p>Here’s a sample of the system as it stands:</p> <pre><code class=language-plain>code-src/tamerlane [trunk] ⊕ mix cli
Compiling 2 files (.ex)
=================
North draws 12 cards.
[North] Hand: %{
  &quot;clubs&quot; =&gt; [#Card&lt;5♣&gt;, #Card&lt;9♣&gt;],
  &quot;diamonds&quot; =&gt; [#Card&lt;6♦&gt;, #Card&lt;T♦&gt;],
  &quot;hearts&quot; =&gt; [#Card&lt;3♥&gt;, #Card&lt;4♥&gt;, #Card&lt;7♥&gt;, #Card&lt;T♥&gt;, #Card&lt;K♥&gt;],
  &quot;spades&quot; =&gt; [#Card&lt;2♠&gt;, #Card&lt;9♠&gt;, #Card&lt;T♠&gt;]
}
South draws 12 cards.
...
West draws 12 cards.
...
East draws 12 cards.
...
Setting Decoration for North: bid_action

[North] Please select 1 of [&quot;3 Uptown&quot;, &quot;3 Downtown&quot;, &quot;3 No-Trumps&quot;, &quot;4 Uptown&quot;, &quot;4 Downtown&quot;,
 &quot;4 No-Trumps&quot;, &quot;5 Uptown&quot;, &quot;5 Downtown&quot;, &quot;5 No-Trumps&quot;, &quot;6 Uptown&quot;,
 &quot;6 Downtown&quot;, &quot;6 No-Trumps&quot;, &quot;7 Uptown&quot;, &quot;7 Downtown&quot;, &quot;7 No-Trumps&quot;, &quot;Pass&quot;] as bid.

North:
  bid_action: bidding
Phase: bid
East/West:
  0
North/South:
  0
Player [North]:  &lt;User input: &lt;ENTER&gt;&gt;
%{
  &quot;clubs&quot; =&gt; [#Card&lt;5♣&gt;, #Card&lt;9♣&gt;],
  &quot;diamonds&quot; =&gt; [#Card&lt;6♦&gt;, #Card&lt;T♦&gt;],
  &quot;hearts&quot; =&gt; [#Card&lt;3♥&gt;, #Card&lt;4♥&gt;, #Card&lt;7♥&gt;, #Card&lt;T♥&gt;, #Card&lt;K♥&gt;],
  &quot;spades&quot; =&gt; [#Card&lt;2♠&gt;, #Card&lt;9♠&gt;, #Card&lt;T♠&gt;]
}
Action: &lt;User input: &quot;3 Uptown&quot;&gt;
=================
Setting Decoration for North: bid_action

Setting Decoration for North: bid

Setting Decoration for South: bid_action

[South] Please select 1 of [&quot;3 No-Trumps&quot;, &quot;4 Uptown&quot;, &quot;4 Downtown&quot;, &quot;4 No-Trumps&quot;, &quot;5 Uptown&quot;,
 &quot;5 Downtown&quot;, &quot;5 No-Trumps&quot;, &quot;6 Uptown&quot;, &quot;6 Downtown&quot;, &quot;6 No-Trumps&quot;,
 &quot;7 Uptown&quot;, &quot;7 Downtown&quot;, &quot;7 No-Trumps&quot;, &quot;Pass&quot;] as bid.

North:
  bid: 3 Uptown
  bid_action: declarer
South:
  bid_action: bidding
Phase: bid
East/West:
  0
North/South:
  0
Player [South]: ▌
</code></pre> <p>If you squint, you can imagine how this same information could be rendered by an interface which knows nothing about Bid Whist itself into a fairly generic but snappy user interface, with your hand at the bottom, a pile of cards in the middle, and all the rest.</p> <p>I’d like to finish both the Whist implementation as well as the command line interface. At that point there are two dimensions I need to expand in: on the one hand, I need to build out the whole website, including the frontend, and there will be all of the challenges and problems of web development that will need to be solved along the way. On the other, I need to build engines for a couple other games that are sufficiently different from bid whist. I need to actually test, in other words, that the DSL I’m putting together is sufficiently generic that it can be relied on by different games and still be understood by the central server, and sufficiently expressive that those games still resemble themselves by the time they’re actually rendered on the page.</p> <section class=footnotes> <ol> <li id=fn1> <p>And there are some significant issues, to be sure. As my partner put it: <em>Isn’t it a problem that your site relies on a bunch of different other websites to be up and working in order for people to be able to play any games?</em> Yes, yes it is. <a href=#fnref1 class=footnote-backref>↩</a></p> </li> <li id=fn2> <p>It will, of course, ultimately be a rich Javascript interface on a website; I’m planning on using Phoenix LiveView since I’m an awful frontend developer. <a href=#fnref2 class=footnote-backref>↩</a></p> </li> </ol> </section> </div> <div class=col-md-3> <h3>Recent Posts</h3> <table class=recent-posts> <tr> <td style=white-space:nowrap>2022-02-19</td> <td><a href=../posts/a-specification-of-a-note-taking-program.html>A Specification of a Note-Taking Program</a></td> </tr> <tr> <td style=white-space:nowrap>2021-03-20</td> <td><a href=../posts/algorithms-im-proud-of-fill.html>Algorithms I'm Proud Of: Fill</a></td> </tr> <tr> <td style=white-space:nowrap>2020-12-10</td> <td><a href=../posts/bagatto-a-new-static-site-generator.html>Bagatto, a New Static Site Generator</a></td> </tr> <tr> <td style=white-space:nowrap>2020-11-22</td> <td><a href=../posts/a-regular-simplification-of-offenbacher-schrift.html>A Regular Simplification of Offenbacher Schrift</a></td> </tr> <tr> <td style=white-space:nowrap>2020-08-20</td> <td><a href=../posts/mariglia.html>Mariglia</a></td> </tr> </table> </div> </div> </div> </div> <hr> <div class=footer>Built with <a href=https://bagatto.co>Bagatto.</a></div> </div> </div> </div> </body> </html> 