<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>Subset Park: Sketches of Elixir</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content="{loglevel, debug}"><meta name=author content="Z. D. Smith"><link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=../assets/bootstrap.min.css rel=stylesheet><link href=../assets/bootstrap-responsive.min.css rel=stylesheet><link href=../assets/styles.css rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/styles/ascetic.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=alternate type=application/rss+xml title=RSS href=../feed.xml></head> <body> <div class=container> <div class=row> <div class=col-md-1></div> <div class=col-md-10> <div class=masthead> <div class=navbar> <div class=navbar-inner> <div class=container> <ul class=nav> <li class=active><a href=../index.html>Home</a></li> <li><a href=../posts/index.html>Posts</a></li> <li><a href=../notes/index.html>Notes</a></li> <li><a href=../pages/about.html>About</a></li> <li><a href=../pages/illustrated-whist.html>Illustrated Whist</a></li> </ul> </div> </div> </div><!-- /.navbar --> </div> <div class=body> <div class=container> <div class=row> <div class=col-md-7> <h1>Sketches of Elixir</h1> <p class=post-info> 2018-12-26 </p> <p>Friends, I am now at least in this respect a rare breed: an Elixir programmer who has never written Ruby.</p> <p>I was never a professional Erlang programmer. I cut my teeth on Python and began working in Python, but Erlang was the language I learned after that and the one that I looked for excuses to write in (in addition to <a href=https://nim-lang.org/ >Nim</a>, which would come a little later, but which I would also be able to finagle into production at MakeSpace).</p> <p>So here was my impression of Elixir for the first several years of my passing acquaintance with it: it’s Erlang with Ruby syntax. I had never ended up writing any Ruby, and I was already happy with Erlang and its syntax. So I had a fairly simplistic understanding of the Elixir language and the roots of its popularity and it didn’t seem that there was anything of value to me.</p> <p>For better or worse, the first thing that many people mention when Erlang comes up is that the syntax is unfamiliar and confusing; at the very least it’s controversial (I love it). Ruby, on the other hand, is vastly more popular than Erlang. So there’s a significant population that finds Erlang syntax eccentric and Ruby conventional and pleasing.</p> <p>On the other hand, there are many reasons to recommend the BEAM, OTP, and the Erlang Runtime System. And concurrent programming and functional programming are now vastly more mainstream than they might have been when Erlang was first developed. So there is a steady stream of object-oriented and/or web application programmers (Ruby or otherwise) taking an interest in Erlang and the BEAM. It would make sense that programmers coming from a Ruby background would find Elixir more palatable.</p> <p>And marks of the Ruby frame of reference are all over Elixir; its creator after all was a <a href=http://plataformatec.com.br/crafting-rails-applications>member of the Rails core team</a>, and its influence is manifest in several areas of the language—especially those parts of it visible from the outside. Not just the syntax, but also a much greater emphasis on programming for the web, including a Rails-like web framework, <a href=https://phoenixframework.org/ >Phoenix</a>.</p> <p>So I didn’t see much of a need for Elixir; it seemed to be a solution for problems I didn’t have.</p> <p>Not to mention, I had a sort of misguided purist’s attitude towards the whole thing. Not that I had the years of Erlang experience to back this up, but new Elixir programmers seemed to me to be <em>arrivistes</em>, or maybe just tourists, barging in and setting up conferences about their new concurrent Ruby. And it was being heralded as the next big thing while Erlang was ignored.</p> <p>I was even sure enough of myself to express this opinion (the part about the language, not the <em>arrivistes</em>) in public—not just in a discussion forum, but one frequented by José Valim, preternaturally patient BDFL of the Elixir language. Someone had posted something along the lines of “what’s the deal with Elixir? Should I learn it instead of Erlang?” and I responded with something along the lines of, “it’s just Erlang with a different syntax. Learn the real thing.”</p> <p>My memory of José’s reply was something like, “that’s a bit reductionist; there’s also macros.” I was embarrassed, not only because I didn’t know that José was going to see my response, but because I didn’t even know there <em>were</em> macros in Elixir.<sup class=footnote-ref><a href=#fn1 id=fnref1>1</a></sup></p> <p>In fact, it’s telling that this is my memory, because on looking back it’s not actually what José said. I won’t quote him directly, but I don’t think it’s breaking too many confidences to give a brief rundown of the features that José cited as distinct (aside from macros), as of early 2015, from Erlang:</p> <ul> <li>lazy collections;</li> <li>more robust structured data (structs);</li> <li>better tooling, incl. testing frameworks and Mix</li> </ul> <p>This is telling because I remember thinking, “well, sure, macros; but Erlang has parse transforms (not that I know how to use them) and macros are weird and shouldn’t be used that much anyway.” I wasn’t a macro guy and, in fact, still am not. I don’t use macros that much today. On the other hand, the part of his reply that I don’t remember, the part about lazy collections, structs and tooling, I use <em>constantly</em>.</p> <p>I started working at <a href=http://frame.io>Frame.io</a> in August 2018. For many reasons, it was a really exciting opportunity for me, one of them being that almost the entire backend application is written in Elixir. For a long time I had been thinking, “wouldn’t it be cool to some day get to write Erlang for a living?” and I wasn’t so much of a chauvinist that I didn’t see the chance to write Elixir full-time to be, modulo some <code>def/end</code>s, just that.</p> <p>Now I’ve been writing Elixir, full-time, for several months. I am for better or worse a fully-converted <em>Elixir</em> programmer. I’d like to believe that I understand the language much better than I did in 2015. I also think that I better understand its place in the BEAM firmament and the wider realm of programming languages. As a programmer with an Erlang background and no Ruby background I might even be in a somewhat unusual position to comment on it. So here’s the actual value proposition for the Elixir language: it’s not Erlang with Ruby syntax; it’s Erlang with a robust and useful standard library and tooling.</p> <p>The thing about the Ruby syntax in Elixir is that it is a complete red herring. It is by far the most superficial and least consequential element of the language<sup class=footnote-ref><a href=#fn2 id=fnref2>2</a></sup>. If you like Ruby syntax, if you dislike Ruby syntax, it doesn’t really matter. You learn it and then you move on. It disappears almost immediately. This is perhaps the first thing I noticed coming to Elixir from Erlang: the base semantics are almost <em>identical</em>. That is, almost every element of the Erlang language is preserved wholesale; Elixir can be seen almost entirely as a series of goodies that are piled on top. This is very reassuring to the Erlanger. You don’t lose any of your intuition for what makes good code.[^assign-once]</p> <p>The second thing you discover as a reluctant Erlang-to-Elixir convert is that the standard library <em>matters</em>. There’s two qualities here, and again neither one of them is as simple as coddling Rubyists who can’t deal with the quirks of the Erlang standard library (1-based indexing, inconsistent naming or argument order…).</p> <p>The first aspect of this is that the specific modules that are pure Elixir innovations are relatively few and obviously well-considered. Big ones are, as mentioned, <code>Stream</code> and <code>Struct</code>. Stream, the lazy collections module, is lovely precisely because there’s nothing unique to Elixir about it; under the hood one imagines it’s got all kinds of protocols and macros and other Elixiry things, but it’s presented to the user simply as exactly the sort of all-purpose highly functional library that you could want from the Erlang standard library too. Structs are more baked into the language itself; There’s a struct syntax based on maps and structs often seem to result in the kind of OO-style data+methods object that you expect out of Python and would never see in Erlang. The tradeoff: you get a certain amount of compile-time checks of attribute access. Static guarantees might be the only thing I would be willing to trade away some of Erlang’s datatype minimalism for.</p> <p>The second aspect is that if you are given the opportunity to greenfield an entire standard library at once on top of everything you get from Erlang already, it turns out you can implement some pretty elegant features. You can, for instance, make sure that the “object” of a function is in the first argument position for every single function, making it possible to introduce the pipe operator <code>|&gt;</code> quite simply.</p> <p>I fucking love pipes. Relatively speaking, there are extremely few assignments in Elixir. Not only because it’s functional and immutable, but because the programmer is encouraged, syntactically, to think about their code as a series of data transformations chained together. If the programmer can do that, they are rewarded with an extremely terse and expressive, at times scarily close to <em>point free</em>, structure. This makes debugging, rearranging, refactoring more straightforward. It reduces parenthesis noise. It’s a big win. Again, it’s not just that it’s less Erlangy for the arbitrary reason that we distrust the Erlang syntax. It makes it easier to write better code.</p> <p>The third thing you discover is that, just maybe, some of this new syntactic sugar is kind of nice. I’ll use keyword arguments as an example. In Elixir you can approximate Python-style positional and named function arguments (<code>f(x, y, z=True)</code>) in syntax: <code>f x, y, z: true</code>. This is exactly the kind of unnecessary imposition of Rubyist tropes that you’re on the lookout for—until you realize that this is actually sugar over an <em>extremely</em> idiomatic Erlangism, the tagged value. <code>[x, y, z: true]</code> is precisely equal to <code>[x, y, [{:z, :true}]]</code>, which is the existing Erlang convention for passing optional parameters to a function, but easier to type and read.</p> <p>This sort of thing ends up being quite reassuring. Sometimes, because Elixir has gotten some heat on it, you read blog posts that talk about Phoenix and microservices in the way that other people talk about Node or React—that is, with an air of hype and untroubled confidence that this is the new best way to build web apps that seems to have come more from reading blog posts than from suffering through the building of many systems. A new, up-and-coming technology always carries with it a penumbra of thought leadership and startup marketing masquerading as how-to blog posts.</p> <p>But in fact the creators of this language seem to understand the Erlang idiom very well and don’t tread too heavily over it. It is possible to reflect on what is essential to Erlang and to imagine how we could extend it if we took it upon ourselves to design several layers of expressiveness on top of it. And the OTP model is very much at work in the Elixir ecosystem: almost all Elixir applications are built on the OTP application model, and the <code>gen_*</code> concept is even extended with new behaviours like <code>GenStage</code>.</p> <p>Of course, the simplicity and flatness of Erlang is not nothing, and Elixir has traded some of that away. With protocols, <code>__using__</code> macros and more, Elixir has many new forms of code reuse and polymorphism than are possible or idiomatic in Erlang. That means there are many more places with <em>magic</em> in them, where an imported module or expanded macro does things that aren’t obvious by reading the code.</p> <p>That said, I’m enormously happy to be working with Elixir. The experience of writing Elixir is a pleasure and there is no better foundation than the BEAM and OTP.</p> <p>In fact, working in Elixir full-time has renewed my interest in the entire BEAM ecosystem. Elixir has demonstrated that the bones of Erlang are valuable and applicable enough to serve as the foundation for programming languages of all flavors. And Elixir programmers are treated with an ecumenical view of the entire BEAM; the Erlang standard library, as well as any Erlang code in the path, is available transparently to be called from Elixir.</p> <p>How can we expand that relationship in the other direction? Calling Elixir code from Erlang, <a href=https://joearms.github.io/published/2017-12-18-Calling-Elixir-From-Erlang.html>while technically possible</a>, is not quite as convenient as just chucking some module files into <code>/src</code>. What can we do to make compiled Elixir code as transparently available to Erlang programmers? Or, for that matter, to <a href=http://lfe.io/ >LFE</a> programmers? How far can we go in making tools like <a href=https://www.rebar3.org>rebar3</a> and mix functionally equivalent? How far can we get towards a truly language-agnostic workflow, running OTP applications with modules written in LFE, Elixir, Erlang, <a href=http://joxa.org/ >Joxa</a>… You get the point.</p> <p>This is what I’d love to see come out of the Elixir language and community. It’s got a wonderful momentum right now; lots of interest, lots of new contributors, and a thoughtful and motivated core team. We have the opportunity to work towards a totally integrated BEAM ecosystem.</p> <section class=footnotes> <ol> <li id=fn1> <p>I am now embarrassed all over again, because going back and reading my early posts in this forum about Erlang I see that not only did I make an ass of myself up there but this was a couple years after <em>José himself</em> had been the person who was most responsive to my initial questions about programming in Erlang. <a href=#fnref1 class=footnote-backref>↩</a></p> </li> <li id=fn2> <p>Except insofar as it’s actually a quite-clever way to put together a surprisingly friendly and readable language that also provides a massive degree of homoiconicity. <a href=#fnref2 class=footnote-backref>↩</a></p> </li> </ol> </section> </div> <div class=col-md-3> <h3>Recent Posts</h3> <table class=recent-posts> <tr> <td style=white-space:nowrap>2022-02-19</td> <td><a href=../posts/a-specification-of-a-note-taking-program.html>A Specification of a Note-Taking Program</a></td> </tr> <tr> <td style=white-space:nowrap>2021-03-20</td> <td><a href=../posts/algorithms-im-proud-of-fill.html>Algorithms I'm Proud Of: Fill</a></td> </tr> <tr> <td style=white-space:nowrap>2020-12-10</td> <td><a href=../posts/bagatto-a-new-static-site-generator.html>Bagatto, a New Static Site Generator</a></td> </tr> <tr> <td style=white-space:nowrap>2020-11-22</td> <td><a href=../posts/a-regular-simplification-of-offenbacher-schrift.html>A Regular Simplification of Offenbacher Schrift</a></td> </tr> <tr> <td style=white-space:nowrap>2020-08-20</td> <td><a href=../posts/mariglia.html>Mariglia</a></td> </tr> </table> </div> </div> </div> </div> <hr> <div class=footer>Built with <a href=https://bagatto.co>Bagatto.</a></div> </div> </div> </div> </body> </html> 