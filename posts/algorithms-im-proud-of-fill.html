<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>Subset Park: Algorithms I'm Proud Of: Fill</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content="{loglevel, debug}"><meta name=author content="Z. D. Smith"><link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=../assets/bootstrap.min.css rel=stylesheet><link href=../assets/bootstrap-responsive.min.css rel=stylesheet><link href=../assets/styles.css rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/styles/ascetic.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=alternate type=application/rss+xml title=RSS href=../feed.xml></head> <body> <div class=container> <div class=row> <div class=col-md-1></div> <div class=col-md-10> <div class=masthead> <div class=navbar> <div class=navbar-inner> <div class=container> <ul class=nav> <li class=active><a href=../index.html>Home</a></li> <li><a href=../posts/index.html>Posts</a></li> <li><a href=../notes/index.html>Notes</a></li> <li><a href=../pages/about.html>About</a></li> <li><a href=../pages/illustrated-whist.html>Illustrated Whist</a></li> </ul> </div> </div> </div><!-- /.navbar --> </div> <div class=body> <div class=container> <div class=row> <div class=col-md-7> <h1>Algorithms I&#39;m Proud Of: Fill</h1> <p class=post-info> 2021-03-20 </p> <blockquote> <p>Array logic operates by a <code>fill</code> algorithm. Fill the ds with the smaller rank to the be the same shape as the ds with the larger.</p> </blockquote> <p>I recently released---so to speak---a new project that has occupied the last several weeks of my free time: a calculator program, called <a href=https://ec-calc.com>EC</a>.</p> <p>I decided to build it for a few reasons. Probably the first reason is that it seemed to be a good use-case for the project I had been working on for the <em>prior</em> few weeks: <a href=https://fugue.soy>Fugue</a>, an object system for the Janet programming language. I had settled on the basic approach and feature set, and built a little <a href=https://git.sr.ht/~subsetpark/the-brzozowski-variations>proof of concept</a>, but obviously if I was going to herald this as the spiritual successor to <a href=https://lispcookbook.github.io/cl-cookbook/clos.html>CLOS</a> it would behoove me to put it through its paces more substantially.</p> <p>A little desk calculator struck me as a nice, mid-sized project, with enough potential for object-orientation that it could potentially benefit from what Fugue offers. It's quite difficult to think of useful software to write; it's much easier to think of useful software libraries, that will help other people make useful software.</p> <p>After I thought of it, it seemed like I could create a sequel to a previous project of mine, <a href=https://github.com/subsetpark/ad><code>ad</code></a>[^nameorigin]. I use <code>ad</code> all the time whenever I need to do one-off arithmetic, so I actually have a vague sense of what I'd like to add to it.</p> <p>[^nameorigin]: <code>ad</code> is so-called because it comes after <code>bc</code>, the venerable calculator program. My partner suggested <code>ce</code> as further development of the naming scheme, which I think is quite good. Somewhere, however, between that suggestion and my creating the repo, I unconsciously transposed the letters, and didn't notice until a little while later.</p> <h2>Array Math</h2> <p>The <a href=https://www.jsoftware.com/ >J language</a>, of which I am a great admirer, though essentially hopeless as a practitioner, has a thorough and powerful <em>array orientation</em>. You can do all kinds of brilliant things with arrays and matrices, manipulating multi-dimensional groups of numbers just as though they were individual numbers. Here's a tiny snippet:</p> <pre><code class=language-J>   (2 3 $ 3 0 0) + 1
4 1 1
4 1 1
</code></pre> <p>In the first line, we take the array <code>3 0 0</code> and <em>shape</em> it into the shape <code>2 3</code>, that is, into a two-dimensional matrix with two rows and three columns. We then add 1 to that entire matrix, which is equivalent to adding 1 to each element of the matrix.</p> <p>In J, there isn't any need to <em>map</em> a function like <code>(lambda (x) (+ x 1))</code> over the matrix; the <code>+</code> operator is &quot;matrix-aware&quot; and has a built-in semantics for how to apply itself to a 2d matrix on the left side and a single number on the right.[^otherj]</p> <p>[^otherj]: In fact (unsurprisingly), the array behaviours of J are far, far richer than in this example, and far richer than what will be demonstrated in the rest of the post. While it's possible that we might be able to incrementally increase the power of shaping and filling in EC, we will certainly not take a language as powerful and subtle as J as our point of comparison.</p> <p>It would be useful to be able to incorporate this kind of behaviour into <code>ad</code>'s successor. EC is still an RPN, stack-based program, and thus we can't have J's pervasive array-orientation; in the J example we get an array &quot;for free&quot; any time we separate two or more numbers with a space. We need spaces to separate all tokens in a stack-based language. Nevertheless, the ability to add, multiply, square, etc. operands of any dimensions would be very much in keeping for a desk calculator designed to be powerful and convenient.</p> <h3>The Fill Algorithm</h3> <p>When I decided I'd like to build this program, my mind set off on it and wouldn't be dissuaded. The quotation at the top of this article is a text I sent to myself on February 17 at 11:35pm, after a sleepless hour or so (typo included). Surprisingly, the initial commit is not until the next day. So I had started entirely conceptually.</p> <p>In point of fact, I'm quite weak when it comes to algorithmic thinking. My mind starts swimming and losing track of things very easily. And I had no idea how you might accomplish this kind of &quot;dimension-agnostic&quot; logic; it seemed kind of magic the last time I had played around in the J REPL.</p> <p>That said, I did come primed with one piece of knowledge: in J, arrays have a <em>shape</em>, which is itself a 1-dimensional array listing the length of each dimension of the original array. For instance, as above, an array with shape <code>2 3</code> is a 2-by-3 matrix; one with <code>2 3 3</code> is a 3-dimensional, 2-by-3-by-3 one. We can follow that to its logical conclusion: if a simple list is a 1-dimensional array, its shape should also be a list, with a single element, which is the length of the list. Finally, that means that the shape of a simple number should be the empty list.</p> <p>The key to the algorithm that occurred to me, like so many of them, feels kind of like a cheat. I simply can't conceptualize of a way to &quot;apply&quot; an array of dimensionality N to an array of dimensionality M. Addition, to take the simplest operation I can think of, only makes sense to me when applied to two numbers. And trying to somehow imagine how to &quot;do the right thing&quot; when one of the operands is a list and the other is a 4-dimensional matrix just hurts my head. Therefore, let's approach that problem from the other direction; instead of figuring out how to add a list and a matrix, or a matrix and a number, what if we just made them both the same exact shape? Then you'd have a one-to-one correspondence between elements and the actual addition would be trivial.</p> <p>Again, I can barely conceptualize what it would mean to &quot;resize&quot; a list into a 4-d matrix. <em>But</em> it's pretty easy to conceptualize what resizing <code>1</code> looks like in the example <code>(2 3 $ 3 0 0) + 1</code>. You just repeat <code>1</code> a bunch of times until you've filled out the whole shape. It seems incredibly wasteful to create all those <code>1</code>s, but conceptually it's quite simple.</p> <p>If we follow that thread, we can start to generalize the concept without hurting our brains too much. If filling <code>1</code> out to the size of a 6-element list is simply repeating <code>1</code> 6 times, then filling <code>3 0 0</code> to a matrix of shape <code>2 3</code> should be simply repeating <code>3 0 0</code> twice. And indeed it is:</p> <pre><code class=language-J>   2 3 $ 3 0 0
3 0 0
3 0 0
</code></pre> <h3>Fills in EC</h3> <p>At this point we depart from J as a useful model. In fact, J has a sophisticated and flexible approach to applying dyadic operators between arrays of differing shapes. It allows the user to select the &quot;rank&quot; across which they want to apply the operator, so that the behaviour implemented in EC is only one of the possible solutions to the problem.</p> <p>That said, the <em>fill</em> algorithm provides a generalizable approach to the problem of applying an operation to operands of differing shape. Given any two vector-or-numbers, fill the smaller-dimensioned one to the shape of the greater-dimensioned one and then apply the operation pairwise.</p> <p>It's important to note that this imposes a significant constraint: the shape of the smaller one has to be a suffix of the shape of the greater one. For instance, a vector of shape <code>3</code> could be filled to a matrix of shape <code>2 3</code> by repeating it twice; however, a vector of shape <code>4</code> couldn't be filled to <code>2 3</code>.</p> <p>I'm happy with this. It addresses the most important case, that of operating on a matrix of any arbitrary size and a single number (the shape of a single number is <code>[]</code>, the empty vector, which is trivially a suffix of any other shape), and there's no special-casing for any specific dimensionality.</p> <h3><code>fill</code> in Janet</h3> <p>Once I had that basic conceptual orientation, I actually found myself articulating the entire algorithm (in prose) in texts to myself. It may simply be a trick of the mind, but to me there is some proof in the &quot;rightness&quot; (I hesitate to say &quot;correctness&quot;!) of the algorithm in the fact that it seemed to unfold naturally, at a conceptual level, once I had oriented my thinking correctly around the topic. The resulting code is a very faithful translation of the texts I sent to myself.[^mytexts]</p> <p>What leaves me feeling good about this as an approach is that the code for <code>fill</code> is concise and elegant. Here is the function that, given a Vector object and a shape to fill it to (expressed as an array of numbers), returns a new Vector of the original data filled to the new shape:</p> <pre><code class=language-lisp>(defmethod fill Vector
  [self shape-to-fill]
  (let [x (array ;(shape self))
        y (array ;shape-to-fill)]

    (while (not (empty? x))
      (let [xi (array/pop x)
            yi (array/pop y)]
        (unless (= xi yi)
          (errorf &quot;Shape error: can't fill vector with shape %q to %q&quot;
                  (shape self) shape-to-fill))))

    (reduce (fn [acc length]
              (let [new-shape (tuple length ;(shape acc))
                    new-data (array/new-filled length acc)]
                (:new Vector new-shape new-data)))
            self
            (reverse y))))
</code></pre> <p>The algorithm is very short:</p> <ol> <li>Start with the shape of the Vector and the shape to be filled into.</li> <li>Repeatedly pop elements off of both until the Vector's shape is consumed; the resulting mutation of the new shape will be the dimensions to expand the original data into.</li> <li>Recurse backwards across the dimensions, repeating the accumulator <code>n</code> times on each step.</li> </ol> <h3>EC in Action</h3> <p>I can now demonstrate the above J behaviour as translated into EC.</p> <p>EC, it should be noted, is written in RPN notation, rather than J's infix notation, so the operations should be read from left to right. EC Vectors are denoted with square brackets <code>[]</code>, as spaces separate stack tokens. The value in between the angle brackets <code>&lt;&gt;</code> on the left side of the prompt show the current top value in the stack.</p> <pre><code class=language-forth>&lt;&gt; $ [3 0 0] [2 3] fill 
&lt;[[3 0 0] [3 0 0]]&gt; $ 1 +
&lt;[[4 1 1] [4 1 1]]&gt; $ 
</code></pre> <p>I've done the operation in two steps, so you can see the matrix that <code>1 +</code> is applied against; it can just as easily be written <code>[3 0 0] [2 3] fill 1 +</code>. We see the same sequence as in the J code: you can <code>fill</code> any data structure to any shape, subject to the suffix constraint named above; and any two data structures can be applied to an operator like <code>+</code> as long as the smaller-shaped of the two---in this case, the number <code>1</code>---is fillable to shape of the larger.</p> <h2>Addendum: Some Words on Fugue</h2> <p>We see above an example of the Fugue framework in the form of <code>defmethod</code>. In the <a href=https://git.sr.ht/~subsetpark/ec/tree/master/item/src/calc.janet>EC code</a>, <code>Vector</code> is a Fugue <em>prototype</em>, and <code>fill</code> is a method specialized to <code>Vector</code>. Janet's OO functionality is built on prototypal inheritance (as opposed to class-based inheritance), and thus in Fugue one defines prototype hierarchies. In EC, <code>Vector</code> is a child of <code>Quotation</code>, which is a child of <code>Element</code>.</p> <p>Fugue offers two ways to define prototype-based behaviour, corresponding to the two major types of behaviour specialization in object-oriented systems: <em>methods</em> and <em>multimethods</em>.</p> <p><em>Methods</em> are functions which are assigned directly to prototype objects (in prototypal inheritance, there are no distinct classes, only objects which other objects designate as their prototypes), and which are therefore inherited by any descendant object of the prototype. Janet provides a native way of calling these assigned functions; syntax like <code>(:foo bar baz)</code>, where <code>:foo</code> is a keyword instead of a regular symbol, translates to <code>((get bar :foo) bar baz)</code>.</p> <p>In EC, we implement <code>fill</code> as a method on <code>Number</code> and <code>Vector</code>, so a call like <code>(:fill (:new Integer 4) [2])</code> will be prototype-aware. (<code>Integer</code>, is a child of <code>Number</code>, of course!)</p> <p>The <code>defmethod</code> macro also defines <code>fill</code> as a function that calls <code>:fill</code>, for added convenience.</p> <p><em>Multimethods</em> can be specialized against the types (or prototypes) of <em>all</em> of their arguments. Instead of being defined for some prototype (and inserted as a method in that prototype table, to be inherited by its descendants), any individual multimethod instance is defined for the type of each of its arguments. Thus, for instance, a multimethod might be defined separately against <code>[Quotation Number]</code> and <code>[Vector Number]</code>.[^axes] [^openmultis]</p> <p>[^axes]: I think of this as operating along the horizontal axis rather than the vertical; multimethods trade the ability to exploit inheritance (a vertical orientation) in dispatch for the ability to dispatch across the entire (horizontal) sequence of argument types together.</p> <p>[^openmultis]: For completeness's sake, I'll mention that multimethods come in two flavors in Fugue: <em>closed</em> and <em>open</em>. Closed multimethods are defined within a single module and can't be extended by other callers; thus, they're roughly analogous to a multi-function-head, pattern-matching system like what you get in Erlang and Elixir.</p> <pre><code>Open multimethods, on the other hand, are declared once and then
can be extended with new cases from anywhere in the
codebase. They're thus closer to what are sometimes known as
*protocols*, in that they provide a way to extend the behaviour of
a function with respect to data types that didn't exist when the
function was declared.

In EC there are examples of both: pretty-printing terms is defined
as a multimethod, while the `push` function (which handles pushing
some term to the stack) is an open multimethod that picks up new
definitions as new data types are developed.
</code></pre> <p>EC has turned out to be an excellent testbed for developing and testing Fugue; it offered some natural opportunities to use almost all of Fugue's features, and over the course of developing EC I hit a bunch of new problems that suggested natural extensions of the existing feature set. By the time I was finished, I felt quite comfortable defining the feature set of Fugue 1.0 as &quot;that which is sufficient to build EC&quot;.</p> <p>[^mytexts]: - Call them x and y<br> Feb 17 11:35pm - Take shape x and shape y<br> Feb 17 11:35pm - Reverse both<br> Feb 17 11:35pm - Assert that sx is a prefix of sy. Else: shape error<br> Feb 17 11:36pm - Consume the prefix of sy. Reduce over the remainder with x as the accumulator.<br> Feb 17 11:37pm - At each iteration , call the shape level sy1 sy2 ... syn, (cycle acc syn)<br> Feb 17 11:38pm</p> </div> <div class=col-md-3> <h3>Recent Posts</h3> <table class=recent-posts> <tr> <td style=white-space:nowrap>2022-02-19</td> <td><a href=../posts/a-specification-of-a-note-taking-program.html>A Specification of a Note-Taking Program</a></td> </tr> <tr> <td style=white-space:nowrap>2021-03-20</td> <td><a href=../posts/algorithms-im-proud-of-fill.html>Algorithms I'm Proud Of: Fill</a></td> </tr> <tr> <td style=white-space:nowrap>2020-12-10</td> <td><a href=../posts/bagatto-a-new-static-site-generator.html>Bagatto, a New Static Site Generator</a></td> </tr> <tr> <td style=white-space:nowrap>2020-11-22</td> <td><a href=../posts/a-regular-simplification-of-offenbacher-schrift.html>A Regular Simplification of Offenbacher Schrift</a></td> </tr> <tr> <td style=white-space:nowrap>2020-08-20</td> <td><a href=../posts/mariglia.html>Mariglia</a></td> </tr> </table> </div> </div> </div> </div> <hr> <div class=footer>Built with <a href=https://bagatto.co>Bagatto.</a></div> </div> </div> </div> </body> </html> 