<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><title>Subset Park: A Specification of a Note-Taking Program</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content="{loglevel, debug}"><meta name=author content="Z. D. Smith"><link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=../assets/bootstrap.min.css rel=stylesheet><link href=../assets/bootstrap-responsive.min.css rel=stylesheet><link href=../assets/styles.css rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/styles/ascetic.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=alternate type=application/rss+xml title=RSS href=../feed.xml></head> <body> <div class=container> <div class=row> <div class=col-md-1></div> <div class=col-md-10> <div class=masthead> <div class=navbar> <div class=navbar-inner> <div class=container> <ul class=nav> <li class=active><a href=../index.html>Home</a></li> <li><a href=../posts/index.html>Posts</a></li> <li><a href=../notes/index.html>Notes</a></li> <li><a href=../pages/about.html>About</a></li> <li><a href=../pages/illustrated-whist.html>Illustrated Whist</a></li> </ul> </div> </div> </div><!-- /.navbar --> </div> <div class=body> <div class=container> <div class=row> <div class=col-md-7> <h1>A Specification of a Note-Taking Program</h1> <p class=post-info> 2022-02-19 </p> <p>I recently watched Conrad Barski’s <a href="https://www.youtube.com/watch?v=4W_m176PIdU">video introducing zek</a>, a program he wrote to take Zettelkasten-style notes on the command line.</p> <p>This is the perfect spur to a programming project: another, already perfectly fine, program that does almost what you want but not exactly. In my case, I was intrigued by the idea of a Zettelkasten-style note-taking app on the command line, but the whole line-editor approach seemed to me to be a bridge too far. So of course I started thinking about how I’d write my <em>own</em>.</p> <p>I came up with an idea that I like, and that is extremely simple, deferring as much as possible to my text editor, and could conceivably be written as a single shell script calling widely-available tools.</p> <p>I thought about it during a couple showers, and then I wrote a <a href=https://pantagruel-language.com>Pantagruel</a> spec for what I came up with. I reproduce that here.</p> <div style="text-align: center; margin: 2em">&#128607;</div> <p>module ZK.</p> <blockquote> <p>Notes on a note-taking system, inspired by Zettelkasten.</p> </blockquote> <p>Line ⇐ String.<br> Note ⇐ [Line].</p> <blockquote> <p>The basic operation we’re describing is <em>indexing</em>: taking all the notes in our set and updating them with references to other notes. That’s all this system does; the notes themselves can be written and read with a standard text editor, and most text editors have a “go to file” procedure, so even the navigation from note to note can be done within the editor.</p> </blockquote> <blockquote> <p>The only thing it needs help with is finding the connections between notes.</p> </blockquote> <p>index notes: [Note].</p> <hr> <blockquote> <p>Indexing does two things:</p> </blockquote> <blockquote> <ol> <li>It updates each note, in place. All backlinks to each note are placed at the beginning of it, and all references contained within it are placed at the end.</li> </ol> </blockquote> <p>all n: notes ⇒<br>    nʹ = backlinks n + body n + references n<br>    and name nʹ = name n.</p> <blockquote> <ol start=2> <li>It maintains an Index. Indices aren’t notes - they aren’t affected by indexing, in particular. They are simply a list of links to each note in the set, ordered by creation time.</li> </ol> </blockquote> <p>some1 i: Index ⇒<br>    all n: notesʹ ⇒ ref-note n in i<br>    and all (n, m): notesʹ ⇒<br>       created-at n &lt; created-at m → i (ref-note n) &lt; i (ref-note m).</p> <p>;</p> <p>Index ⇐ [Line].</p> <blockquote> <p>A Reference is a line of text that’s read and written by the system. Both backlinks and (forward) references are simply collections of References.</p> </blockquote> <p>Reference ⇐ Line.<br> backlinks n: Note ⇒ {Reference}.<br> references n: Note ⇒ [Reference].</p> <p>name n: Note ⇒ String.<br> body n: Note ⇒ [Line].<br> created-at n: Note ⇒ Date.</p> <p>ref s: String ⇒ Reference.<br> ref-note n: Note ⇒ Reference.</p> <hr> <blockquote> <p>To refer to a given name, we simply insert a line with a recognized string in front of it, followed by the name. For instance: <code>%ref:scifi\ authors</code>. In particular, it’s important to escape any delimiters in the name; this is to allow the “go to file under cursor” command to recognize the whole name rather than the first part, in the case of names with spaces.</p> </blockquote> <p>ref s = <code>%ref:</code> + escape s + <code>\n</code>.</p> <blockquote> <p>It follows then that a reference to a note is simply a reference to its filename.</p> </blockquote> <p>ref-note n = ref (name n).</p> <p>body n = [all line: n, ~(line in Reference) ⇒ line].</p> <blockquote> <p>As mentioned above, to <em>index</em> a note is to take the note body, prepend all of the backlinks to that note, and append all the references to other notes (or other potential notes) contained in the body. A backlink is a reference to any note that links to this one; a (forward) reference is a reference to any note which is linked to by this one.</p> </blockquote> <p>backlinks n = {all m: Note, (bracketed (name n)) in m ⇒ ref-note m}.<br> references n = [all s: String, (bracketed s) in n ⇒ ref s].</p> <blockquote> <p>It’s worth noting that references can be ordered as they appear in the note body; but backlinks have no defined order.</p> </blockquote> <p>all (r, s): references n ⇒<br>    n (bracketed (name r)) &lt; n (bracketed (name s)) → references r &lt; references s.</p> <p>;</p> <blockquote> <p>To link to any name, simply enclose it in square brackets in the body of a note.</p> </blockquote> <p>escape s: String ⇒ String.<br> bracketed s: String ⇒ String.</p> <hr> <p>bracketed s = <code>[</code> + s + <code>]</code>.</p> <div style="text-align: center; margin: 2em">&#128607;</div> <p>I invite you to read the above; hopefully you like the idea of such a program. I intend to write it. Hopefully, in fact, you could write it too; hopefully the spec is descriptive enough that we could write two programs which did the same thing.</p> <p>There’s English prose in it, of course, and no doubt you’d refer to that when you wrote it. And it doesn’t constitute the entire documentation for such a program; there’s no description of how the thing is intended to be used. And there’s certainly no description of the rationale for the program or its values.</p> <hr> <p>The rationale is this: I very much like the core idea of the note system, as it’s presented in <code>zek</code>: a flat directory of text files, linked to other ones (a Wiki, so far), and comprehensively and automatically <em>backlinked</em> as well (not so much a Wiki); and a time-ordered index to bind them all together.</p> <p>But in my mind, vim is already a wonderful tool for writing text. There’s absolutely no need to reimplement a text editor if text files are your medium of choice. And with <code>gf</code>, it’s not a half-bad one for navigating the links either.</p> <p>What’s left is actually quite small. You simply need a program that will scan all the text files in a directory, find all the [square brackets references], create a quasi-organized list of filenames corresponding to those square brackets as metadata in the files themselves, and create a quasi-organized list of all the filenames containing references to <em>this</em> file in them too. You can do all that with awk. The distinctive <code>%ref:</code> syntax is just to make it easy to filter those lines out when you generate a new generation of the file.</p> <hr> <p>Nevertheless, I do think there’s a lot of worth in actually writing a specification of some sort, as I’ve done above.</p> <p>One reason is: there’s an entire largely-unpracticed art of <em>describing</em> programs rather than <em>writing</em> them. The most successful example that comes to mind is <a href=http://cr.yp.to/redo.html><code>redo</code></a>, as conceived by the brilliant D. J. Bernstein. <code>redo</code> is a program that Bernstein didn’t (or we might say, didn’t bother to) write; he merely described a hypothetical program with enough clarity that there are <a href=https://github.com/apenwarr/redo>at least</a> <a href=https://github.com/leahneukirchen/redo-c>two</a> existing implementations of the system, written by others. I like this idea; it would tickle me pink to see others write the program that I’ve described and compare it to the program in my head.</p> <p>Another, though, is that I maintain there’s enormous worth in thinking critically and deeply about a program <em>before</em> one writes it. There is an extent to which idle shower thoughts fulfill this role. But there are other, deeper ways to think about parts of a program like its core primitives, its vocabulary, its invariants, its edge cases, its sequence of operations, and so on, and we rarely as a field avail ourselves of them.</p> <p>There’s the whole subfield of <a href=https://www.hillelwayne.com/ >formal methods</a>, of course, but I think you’ll agree that the above document is business casual methods at best. This is Formal Methods Ultralite, and I think it has some worth; in fact I think part of its worth is how lightweight it is. I knocked that out in an hour.</p> <hr> <p>And yet: I understand the program more deeply now than when I wrote it.</p> <p>The first step is, add the English last. The English is for the reader, but it’s best written only after one is confident that one fully understands what they’re about to describe. Otherwise, natural language has a tendency to infect thought; because we have a name or a phrase to encompass something, we think we understand it; but natural language is full of ambiguities, pronouns without clear referents, double meanings, unclear phrasing, and more.</p> <p>Indeed, the style that Pantagruel encourages is a naturally explanatory one. I start by describing, quasi-formally, the behaviour of the program in a “sentence” or two. In doing so, two things happen:</p> <ol> <li> <p>The formality begins to work its magic. Things that are easy to express in English are harder to express in the sentence structures of first-order logic, and that’s often because the English thoughts refer to things without introducing them, and the like. So I have to introduce things and then I realize I haven’t thought through all of their contours.</p> </li> <li> <p>I introduce some new terminology. To explain my program at a high level, I necessarily refer to certain other qualities or concepts. When I run <code>pant</code>, I get this error message:</p> <pre><code>error: Unglossed symbols:

name, references, created_at, body, backlinks, ref_note, Index
</code></pre> <p>So, this is the next layer down. These are the concepts I must elaborate on; left to my own devices, I might have remembered to explain some of them, but probably not all.</p> </li> </ol> <p>So I introduce a new chapter and continue the process. I recurse, until I hit the leaves. That is: I run <code>pant</code> and I see no error message. There are no terms left to explain. I’m sure I don’t need to mention that it is through the act of explanation that we stumble on every notion we don’t actually understand, even though we think we did, and are forced to clarify it for ourselves, and in doing so are often shown exactly which two concepts are subtly incompatible, which definition is used differently in different places, and so forth.</p> <hr> <p>All of this without writing any code. All, in fact, without even having decided what language I’ll use to write it. I say this <em>not</em> in the sense of “it’s just that easy!” I am not a believer in the no-code revolution. I like code. Indeed, that’s the problem: code is powerful and seductive and has its own gravity. Putting ideas into code makes them <em>real</em> and gives them an inertia, even if they’re the wrong ideas. Thinking about things beforehand is a valuable practice. It’s valuable because it can be a much higher-leverage way to figure them out than to write a whole program until you realize you didn’t understand the assignment; it’s also valuable because they <em>remain ideas</em>. And in a language like Pantagruel, they’re short little sentences, little bits of pseudo-math. They’re easy to edit. They’re easy to type, to write on a whiteboard or notebook, and easy to erase and change.</p> </div> <div class=col-md-3> <h3>Recent Posts</h3> <table class=recent-posts> <tr> <td style=white-space:nowrap>2022-02-19</td> <td><a href=../posts/a-specification-of-a-note-taking-program.html>A Specification of a Note-Taking Program</a></td> </tr> <tr> <td style=white-space:nowrap>2021-03-20</td> <td><a href=../posts/algorithms-im-proud-of-fill.html>Algorithms I'm Proud Of: Fill</a></td> </tr> <tr> <td style=white-space:nowrap>2020-12-10</td> <td><a href=../posts/bagatto-a-new-static-site-generator.html>Bagatto, a New Static Site Generator</a></td> </tr> <tr> <td style=white-space:nowrap>2020-11-22</td> <td><a href=../posts/a-regular-simplification-of-offenbacher-schrift.html>A Regular Simplification of Offenbacher Schrift</a></td> </tr> <tr> <td style=white-space:nowrap>2020-08-20</td> <td><a href=../posts/mariglia.html>Mariglia</a></td> </tr> </table> </div> </div> </div> </div> <hr> <div class=footer>Built with <a href=https://bagatto.co>Bagatto.</a></div> </div> </div> </div> </body> </html> 